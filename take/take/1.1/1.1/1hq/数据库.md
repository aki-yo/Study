# 注解

tablefield
更新策略
限制更新的范围等

tablelogic逻辑删除是通过这个注解实现的

tablename

前端传递 cunrrent size 构造page对象 传递到函数 参数传入page对象来实现分页查询

# Mybatis-plus



这段代码使用了 MyBatis-Plus 的 `Wrappers.lambdaQuery()` 方法来构建一个条件查询包装器（`QueryWrapper` 或 `LambdaQueryWrapper`），具体解释如下：

### 代码解析

java

```java
Wrappers.<SysRoleLimit>lambdaQuery()
    .eq(ObjectUtil.isNotEmpty(sysRoleLimit.getOrgCode()), SysRoleLimit::getOrgCode, sysRoleLimit.getOrgCode())
```

1. **`Wrappers.<SysRoleLimit>lambdaQuery()`**
    
    - 创建一个泛型为 `SysRoleLimit` 的 Lambda 表达式条件构造器
    - 使用 Lambda 表达式可以避免硬编码字段名（编译时检查字段名正确性）
2. **`.eq()` 条件**
    
    - 添加一个等值查询条件（WHERE org_code = ?）
    - 方法签名：`eq(boolean condition, R column, Object val)`
3. **`ObjectUtil.isNotEmpty(sysRoleLimit.getOrgCode())`**
    
    - 这是一个条件判断（来自 Hutool 工具包）
    - 只有当 `orgCode` 不为 null 且不是空字符串时，才会添加这个查询条件
    - 相当于动态 SQL 的效果
4. **`SysRoleLimit::getOrgCode`**
    
    - Java 8 方法引用，指向 `SysRoleLimit` 类的 `getOrgCode()` 方法
    - 等价于 SQL 中的字段名 `org_code`（MyBatis-Plus 会自动转换）
5. **`sysRoleLimit.getOrgCode()`**
    
    - 查询条件的值，来自 `sysRoleLimit` 对象的 `orgCode` 属性

### 等价 SQL

如果 `sysRoleLimit.getOrgCode()` 返回 `"dept001"`，生成的 SQL 类似：

sql

```sql
SELECT * FROM sys_role_limit WHERE org_code = 'dept001'
```

如果 `orgCode` 为 null 或空字符串，则不会添加该条件：

sql

```sql
SELECT * FROM sys_role_limit
```

### 特点说明

1. **类型安全**：使用方法引用代替字符串字段名，避免拼写错误
2. **动态条件**：通过前置条件判断实现动态 SQL
3. **链式调用**：可以继续拼接其他条件，例如：
    
    java
    
    ```java
    .eq(...)
    .gt(...)
    .orderByAsc(...)
    ```
    

### 完整示例

java

```java
List<SysRoleLimit> list = sysRoleLimitMapper.selectList(
    Wrappers.<SysRoleLimit>lambdaQuery()
        .eq(ObjectUtil.isNotEmpty(sysRoleLimit.getOrgCode()), SysRoleLimit::getOrgCode, sysRoleLimit.getOrgCode())
        .eq(SysRoleLimit::getIsActive, 1)
        .orderByAsc(SysRoleLimit::getCreateTime)
);
```

这种写法是 MyBatis-Plus 推荐的 Lambda 表达式写法，比传统的字符串字段名方式更安全、更优雅。


# 数据库

部门岗位 pos   job 标准岗位 -》 基本信息


sql经验
# [sql解析](sql解析.md)

# [数据库表](数据库/数据库表.md)
# sql知识



```
SELECT  
C_EMPLOYEE_ID,  
C_EXPECT_EXIT_DATE,  
C_HANDLING_DATE,  
row_number() over(partition by C_EMPLOYEE_ID ORDER BY C_OPERATE_TIME DESC) ID  
FROM TB_STA_EXIT_APPROVAL
```
结果样例如下：

| C_EMPLOYEE_ID | C_EXPECT_EXIT_DATE | C_HANDLING_DATE | ID  |
| ------------- | ------------------ | --------------- | --- |
| E1001         | 2023-10-15         | 2023-09-20      | 1   |
| E1001         | 2023-09-30         | 2023-09-10      | 2   |
| E1002         | 2023-11-01         | 2023-09-25      | 1   |
| E1003         | 2023-10-20         | 2023-09-18      | 1   |
| E1003         | 2023-10-10         | 2023-09-05      | 2   |
| E1003         | 2023-09-30         | 2023-08-20      | 3   |




```xml
<insert id="insertSysPermissionSpecial" parameterType="SysPermissionSpecial" useGeneratedKeys="true" keyProperty="id">  
    insert into sys_permission_special  
    <trim prefix="(" suffix=")" suffixOverrides=",">  
        <if test="empCode != null and empCode != ''">emp_code,</if>  
        <if test="empName != null and empName != ''">emp_name,</if>  
        <if test="orgHid != null and orgHid != ''">org_hid,</if>  
     </trim>  
    <trim prefix="values (" suffix=")" suffixOverrides=",">  
        <if test="empCode != null and empCode != ''">#{empCode},</if>  
        <if test="empName != null and empName != ''">#{empName},</if>  
        <if test="orgHid != null and orgHid != ''">#{orgHid},</if>  
     </trim>  
</insert>
```

insert values select

not exits 用于排除某些组合

gruopby
group_concat

```sql
SELECT  
    MIN(uu.id) AS id,    uu.user_code,    MAX(u.nick_name) AS nick_name,    GROUP_CONCAT(DISTINCT CASE WHEN uu.type = '2' THEN uu.org_code ELSE NULL END) AS org_code,    GROUP_CONCAT(DISTINCT CASE WHEN uu.type = '2' THEN d.dept_name ELSE NULL END) AS dept_name,    GROUP_CONCAT(DISTINCT CASE WHEN uu.type = '1' THEN uu.role_id ELSE NULL END) AS role_id,    GROUP_CONCAT(DISTINCT CASE WHEN uu.type = '1' THEN r.role_name ELSE NULL END) AS role_nameFROM  
    sys_user_upm uu        LEFT JOIN sys_dept d ON d.dept_id = uu.org_code AND d.status = '0' AND d.del_flag = '0' AND d.is_deleted = 0        LEFT JOIN sys_role r ON r.role_id = uu.role_id AND r.status = '0' AND r.del_flag = '0'        LEFT JOIN sys_user u ON u.user_name = uu.user_code AND u.status = '0' AND u.del_flag = '0'WHERE  
    uu.is_deleted = 0GROUP BY  
    uu.user_code
```


- 查询和“李军”同性别并同班的同学Sname.

```
select sname
from STUDENT
where (SSEX, CLASS) = (select
                         SSEX,
                         CLASS
                       from STUDENT
                       where SNAME = '李军');
```





# 拼接

```
CASE WHEN U.C_LEVEL IN (2,3,7) THEN U.C_NAME||'合计'  
ELSE U.C_NAME END fourName,
```

U.C_NAME||'合计'  
sql的字符串拼接操作




## count

count(1)搭配gruopby使用
count(1) 和 count(\*)
效果一样
1. **`COUNT(expr)` 的作用**：
    
    - 它计算的是 `expr` **不为 NULL** 的行数。
        
    - 由于 `1`、`2` 或任何常量值（如 `'A'`、`100`）都**不是 NULL**，所以数据库引擎会对每一行都计数。


## NVL

`NVL(UPR.C_PROPERTIES,'1')` 是 Oracle 数据库中的一个函数调用，用于处理 `NULL` 值。它的含义如下：

- **`NVL(expr1, expr2)`**：如果 `expr1` 的值为 `NULL`，则返回 `expr2`；否则返回 `expr1`。
- 在你的例子中：
  - `UPR.C_PROPERTIES` 是从子查询中获取的字段。
  - 如果 `UPR.C_PROPERTIES` 的值为 `NULL`，那么 `NVL(UPR.C_PROPERTIES,'1')` 将返回 `'1'`。
  - 如果 `UPR.C_PROPERTIES` 不为 `NULL`，则直接返回 `UPR.C_PROPERTIES` 的值。

### 示例
假设 `UPR.C_PROPERTIES` 可能为以下情况：
- `NULL` → 返回 `'1'`
- `'0'` → 返回 `'0'`

### 应用场景
在这个 SQL 中，它的作用是确保 `C_PROPERTIES` 字段始终有一个非空值（要么是原始值，要么默认为 `'1'`），以避免后续逻辑因为 `NULL` 出现异常或不符合预期的结果。





## `'0' AS C_PROPERTIES`

`'0' AS C_PROPERTIES` 是 SQL 中的一个字段别名定义，具体含义如下：

- `'0'`：这是一个字符串常量，表示固定的值 `'0'`。
- `AS C_PROPERTIES`：将这个常量值赋予一个别名 `C_PROPERTIES`，这样在外部查询中可以像使用表字段一样引用它。

### 具体作用
在这个 SQL 片段中：
```sql
SELECT U.C_HID, '0' AS C_PROPERTIES FROM TB_ORG_ORGUNIT U WHERE ...
```

它的意思是：
- 从表 `TB_ORG_ORGUNIT` 中查询字段 `C_HID`。
- 同时为每条记录固定添加一个名为 `C_PROPERTIES` 的列，并且该列的值始终为字符串 `'0'`。

### 应用场景
这种写法通常用于以下目的：
1. **数据标记**：将某些特定的数据打上标签（如 `'0'` 表示某种状态或分类）。
2. **联合查询兼容性**：确保子查询的结果集结构与主查询期望的字段一致，即使某些字段不是原始表中的字段。
3. **默认值填充**：当某个字段可能为空或不存在时，通过 `AS` 提供一个默认值和字段名。

### 示例
假设 `TB_ORG_ORGUNIT` 表中数据如下：
| C_HID         |
|---------------|
| org_001       |
| org_002       |

则该子查询结果会是：
| C_HID   | C_PROPERTIES |
|---------|--------------|
| org_001 | '0'          |
| org_002 | '0'          |

无论实际数据如何，`C_PROPERTIES` 列的值始终为 `'0'`。





