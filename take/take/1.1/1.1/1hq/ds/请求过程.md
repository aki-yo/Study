# DispatcherServlet\ServletResponse\ServletRequest\FilterChain 过滤器和拦截器\HttpServletRequest\HttpServletResponse

给我解释这些东西之间的关系，联系，是谁封装了谁，调用了谁，执行过程什么



# Spring MVC 核心组件关系及执行流程详解

## 一、核心组件关系图

```
HTTP Request
    │
    ▼
Servlet Container (Tomcat/Jetty等)
    │
    ▼
FilterChain (多个Filter)
    │
    ▼
DispatcherServlet (前端控制器)
    │
    ▼
HandlerInterceptor Chain (拦截器链)
    │
    ▼
Controller (业务控制器)
    │
    ▼
ViewResolver & View (视图解析和渲染)
    │
    ▼
HTTP Response
```

## 二、组件职责及封装关系

### 1. Servlet API 基础组件

**ServletRequest/ServletResponse**
- **本质**：Java Servlet 规范定义的接口
- **提供者**：Servlet 容器(Tomcat/Jetty等)创建并传入
- **封装关系**：
  - 容器收到HTTP请求后创建原始对象
  - 经过Filter和Servlet的层层封装(如Spring的ContentCachingRequestWrapper)

**HttpServletRequest/HttpServletResponse**
- 是ServletRequest/ServletResponse的子接口
- 添加了HTTP协议相关方法(getHeader, getMethod等)

### 2. FilterChain (过滤器链)

**职责**：
- 管理多个Filter的顺序执行
- 决定是否继续执行后续Filter或直接返回

**封装关系**：
- 由Servlet容器创建
- 每个Filter调用`chain.doFilter()`时，容器会传递同一个FilterChain实例

### 3. DispatcherServlet (前端控制器)

**职责**：
- Spring MVC的核心入口
- 统一处理所有请求并协调各组件工作

**封装关系**：
- 本质是一个Servlet(继承自HttpServlet)
- 封装了HandlerMapping、HandlerAdapter等组件
- 会包装原始的Request/Response对象

## 三、完整执行流程

### 1. 请求到达Servlet容器
- 容器创建：
  - `HttpServletRequest`对象(封装请求信息)
  - `HttpServletResponse`对象(封装响应信息)
  - `FilterChain`对象(包含所有匹配的Filter)

### 2. FilterChain执行
```java
public void doFilter(ServletRequest request, ServletResponse response) {
    // 执行第一个Filter的逻辑
    filter1.doFilter(request, response, this); // this指代FilterChain
}
```

每个Filter的典型实现：
```java
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) {
    // 1. 前置处理(如记录日志、设置编码)
    HttpServletRequest request = (HttpServletRequest) req;
    
    // 可能包装请求/响应对象
    ContentCachingRequestWrapper wrappedRequest = new ContentCachingRequestWrapper(request);
    
    // 2. 决定是否继续执行
    if (shouldContinue) {
        chain.doFilter(wrappedRequest, res); // 调用下一个Filter或Servlet
    }
    
    // 3. 后置处理(如修改响应头)
}
```

### 3. 到达DispatcherServlet
- 最后一个Filter调用`chain.doFilter()`后
- 容器调用DispatcherServlet的service()方法
- DispatcherServlet开始Spring MVC处理流程

### 4. Spring MVC内部流程
1. **请求预处理**：
   - 检查是否是multipart请求
   - 查找适用的Handler(Controller方法)

2. **拦截器前置处理**：
```java
// HandlerExecutionChain中的applyPreHandle方法
for (HandlerInterceptor interceptor : interceptors) {
    if (!interceptor.preHandle(request, response, handler)) {
        // 如果返回false，中断执行
        return;
    }
}
```

3. **控制器方法执行**：
   - 通过HandlerAdapter执行实际Controller方法
   - 参数解析(@RequestParam, @RequestBody等)
   - 返回值处理

4. **拦截器后置处理**：
```java
// 逆序执行postHandle
for (int i = interceptorList.size() - 1; i >= 0; i--) {
    interceptorList.get(i).postHandle(request, response, handler, mv);
}
```

5. **视图渲染**：
   - 处理@ResponseBody或视图名称
   - 调用ViewResolver解析视图
   - 调用View的render方法

6. **拦截器最终处理**：
```java
// 最终通知(无论成功或异常都会执行)
for (HandlerInterceptor interceptor : interceptors) {
    interceptor.afterCompletion(request, response, handler, ex);
}
```

### 5. 响应返回路径
- 经过DispatcherServlet处理后的响应
- 逆序经过Filter的后续处理
- 最终由容器写入HTTP响应

## 四、关键区别与联系

### Filter vs Interceptor

| 特性                | Filter (过滤器)               | Interceptor (拦截器)           |
|---------------------|-----------------------------|-------------------------------|
| 所属层次            | Servlet规范(容器层面)        | Spring MVC框架层面             |
| 依赖                | 仅依赖Servlet API            | 依赖Spring上下文               |
| 执行时机            | 在DispatcherServlet之前/之后 | 在Controller方法前后           |
| 获取信息            | 原始Servlet请求/响应         | 可以获取HandlerMethod等信息    |
| 异常处理            | 只能处理Filter链中的异常     | 可以处理Controller抛出的异常   |
| 配置方式            | web.xml或@WebFilter          | 实现接口+WebMvcConfigurer配置  |

### 封装关系总结

1. **请求/响应对象流转**：
   ```
   原始Servlet对象 → Filter包装 → DispatcherServlet包装 → 控制器使用
   ```

2. **调用顺序**：
   ```
   容器 → Filter1 → Filter2 → ... → DispatcherServlet → 拦截器 → 控制器
   ```

3. **响应路径**：
   ```
   控制器 → 拦截器 → DispatcherServlet → FilterN → ... → Filter1 → 容器
   ```

## 五、典型应用场景

### Filter适用场景：
1. 跨域处理(CORS)
2. 请求/响应日志记录
3. 字符编码设置
4. 安全过滤(XSS防护)
5. 压缩响应内容

### Interceptor适用场景：
1. 权限验证
2. 业务日志(记录Controller调用)
3. 参数预处理
4. 响应结果统一包装
5. 接口耗时统计

## 六、代码示例：完整调用链

```java
// 1. Filter示例
@WebFilter("/*")
public class LogFilter implements Filter {
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) {
        long start = System.currentTimeMillis();
        HttpServletRequest request = (HttpServletRequest) req;
        
        System.out.println("Filter开始: " + request.getRequestURI());
        
        // 继续执行过滤器链
        chain.doFilter(request, res); 
        
        long duration = System.currentTimeMillis() - start;
        System.out.println("Filter结束, 耗时: " + duration + "ms");
    }
}

// 2. Interceptor示例
public class AuthInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) {
        System.out.println("Interceptor前置处理");
        return true; // 继续执行
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                         HttpServletResponse response, 
                         Object handler, ModelAndView mv) {
        System.out.println("Interceptor后置处理");
    }
}

// 3. 配置Interceptor
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new AuthInterceptor());
    }
}

// 4. Controller示例
@RestController
public class DemoController {
    @GetMapping("/test")
    public String test() {
        System.out.println("Controller方法执行");
        return "Hello World";
    }
}
```

## 七、执行过程可视化

```
1. HTTP请求到达Tomcat
   │
2. Tomcat创建:
   ├─ HttpServletRequest
   ├─ HttpServletResponse
   └─ FilterChain(包含LogFilter)
   │
3. LogFilter.doFilter()
   │  print "Filter开始"
   │  ▼
4. chain.doFilter() → 调用DispatcherServlet
   │  ▼
5. DispatcherServlet确定HandlerMapping
   │  ▼
6. AuthInterceptor.preHandle()
   │  print "Interceptor前置处理"
   │  ▼
7. DemoController.test()
   │  print "Controller方法执行"
   │  ▼
8. AuthInterceptor.postHandle()
   │  print "Interceptor后置处理"
   │  ▼
9. 返回响应路径
   │  ▼
10. LogFilter继续执行
    │  print "Filter结束"
    │  ▼
11. Tomcat发送HTTP响应
```

理解这些组件的协作关系对于开发高效的Web应用和排查问题非常重要，特别是在需要定制请求处理流程时。












# HttpServletRequest/HttpServletResponse

## HttpServletRequest/HttpServletResponse

是ServletRequest/ServletResponse的子接口

添加了HTTP协议相关方法(getHeader, getMethod等)

那HttpServletRequest是一个类还是一个接口，子接口的意思是继承吗

`HttpServletRequest` 是一个**接口**，而不是类。  

### 关键点解析：
1. **`HttpServletRequest` 是接口**  
   - 它继承自 `ServletRequest`，并增加了 HTTP 协议相关的方法（如 `getHeader()`, `getMethod()`, `getCookies()` 等）。  
   - 在 Java 中，接口可以**继承（extends）另一个接口**，这就是“子接口”的含义。  

2. **子接口（继承关系）**  
   - `HttpServletRequest` **扩展（extends）**了 `ServletRequest`，因此它拥有 `ServletRequest` 的所有方法，并额外定义了 HTTP 特有的方法。  
   - 类似地，`HttpServletResponse` 扩展了 `ServletResponse`。  

3. **实现类由 Servlet 容器提供**  
   - 虽然 `HttpServletRequest` 是接口，但实际运行时，Servlet 容器（如 Tomcat、Jetty）会提供它的**实现类**（如 Tomcat 中的 `org.apache.catalina.connector.RequestFacade`）。  
   - 开发者通常不直接接触实现类，而是通过接口标准操作。  

### 示例代码：
```java
// 这是一个接口，继承自 ServletRequest
public interface HttpServletRequest extends ServletRequest {
    // HTTP 相关方法
    String getHeader(String name);
    String getMethod();
    // ... 其他方法
}
```

### 总结：
- **`HttpServletRequest` 是接口**，不是类。  
- **子接口**指的是它通过 `extends` 继承了 `ServletRequest` 接口。  
- 实际运行时，由 Servlet 容器提供具体实现。  

这种设计符合 Java 面向接口编程的原则，使得 Servlet 规范与具体容器实现解耦。








# MVC处理流程总结

1. 请求到达`DispatcherServlet`
    
2. 查找合适的处理器映射(`HandlerMapping`)
    
3. 执行拦截器预处理方法
    
4. 调用控制器方法
    
5. 处理返回结果(视图名或响应体)
    
6. 执行拦截器后处理方法
    
7. 视图渲染(如适用)
    
8. 返回响应
