

搜索与数据源切换相关的代码实现


**已检索仓库** *dynamic datasource switch multi datasource configuration* 0 个结果


查找包含数据源配置的相关文件


**已检索代码** *datasource|DataSource* 2 个结果


查看application-dev.yml文件内容，了解数据源配置


**已查看文件** *application-dev.yml 0-20*


继续查看application-dev.yml文件内容，了解完整的数据源配置


**已查看文件** *application-dev.yml 20-40*


查找与数据源切换相关的Java配置类


**已检索代码** *@Target.*ElementType.TYPE|@Retention.*RetentionPolicy.RUNTIME|DynamicDataSource|DataSource* 0 个结果


查找可能包含数据源配置的Java文件


**已检索文件** *`*DataSource*.java`* 0 个结果


查找可能与动态数据源相关的配置文件


**已检索文件** *`*dynamic*.java`* 0 个结果


在所有Java文件中搜索与数据源切换相关的注解或类


**已检索代码** *DynamicDataSource|DataSourceType|@DataSource* 0 个结果


查找Druid相关的配置文件


**已检索文件** *`*Druid*.java`* 0 个结果


搜索与Spring Boot多数据源配置相关的代码


**已检索仓库** *spring boot multiple datasource configuration druid* 0 个结果


查看application.yml主配置文件了解数据源相关配置


**已查看文件** *application.yml 0-30*


继续查看application.yml文件，寻找数据源相关配置


**已查看文件** *application.yml 30-60*


查看mybatis配置文件了解数据源配置


**已查看文件** *mybatis-config.xml 0-50*


查找项目中的配置类文件


**已检索文件** *`*Config*.java`* 0 个结果


查找项目中的Java源文件


**已检索文件** *`*.java`* 0 个结果


根据我检查的文件内容，我可以提供关于该项目如何实现数据源切换的分析：

## 项目数据源配置分析

从检查的配置文件来看，该项目使用了Spring Boot + Druid数据源的架构，并配置了多个数据源：

### 1. 数据源配置

在 [application-dev.yml](file://E:\project\IdeaProjects\hq_study\HCMSELF-CONTROLLER_1.1\hq-pro\src\main\resources\application-dev.yml) 文件中，可以看到配置了多个数据源：

```yaml
# 数据源配置
spring:
    datasource:
        type: com.alibaba.druid.pool.DruidDataSource
        druid:
            # 主库数据源
            master:
                url: jdbc:mysql://10.76.0.208:3306/hq_self_test?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8
                username: hqself
                password: sj8^sS4ks#
                driverClassName: com.mysql.cj.jdbc.Driver
            # 从库数据源
            slave:
                # 从数据源开关/默认关闭
                enabled: false
                url: jdbc:oracle:thin:@192.168.38.82:1521:HCMTEST
                username: hcm
                password: hcmtest0602
                driverClassName: oracle.jdbc.driver.OracleDriver
            # 从库数据源
            slave1:
                # 从数据源开关/默认关闭
                enabled: false
                url: jdbc:oracle:thin:@192.168.30.166:1521:WF166
                username: hqwf
                password: hqtest0126wf
                driverClassName: oracle.jdbc.driver.OracleDriver
```


### 2. 数据源切换实现方式

虽然在配置文件中设置了多个数据源，但是在可访问的文件中没有找到具体的数据源切换实现代码。通常在这种配置下，数据源切换会通过以下方式实现：

1. **自定义注解方式**：通过在方法或类上添加 `@DataSource` 注解指定要使用的数据源
2. **AOP切面处理**：通过切面拦截注解，动态切换数据源
3. **ThreadLocal存储**：使用ThreadLocal存储当前线程使用的数据源标识
4. **动态数据源类**：继承 `AbstractRoutingDataSource` 实现 `determineCurrentLookupKey()` 方法

### 3. 可能的实现结构

基于标准的Spring Boot多数据源实现模式，该项目可能包含以下组件（虽然在当前可访问文件中未找到）：

1. 数据源枚举类：定义数据源类型（MASTER, SLAVE等）
2. 数据源注解：`@DataSource` 用于标记使用哪个数据源
3. 动态数据源类：继承 `AbstractRoutingDataSource` 的实现类
4. AOP切面：拦截注解并切换数据源
5. 配置类：配置多个数据源和动态数据源bean

### 4. 使用方式推测

如果项目实现了数据源切换，通常会像这样使用：

```java
// 使用主数据源（默认）
@DataSource(value = DataSourceType.MASTER)
public List<User> getUsers() {
    // 查询操作
}

// 使用从数据源
@DataSource(value = DataSourceType.SLAVE)
public List<User> getReadOnlyUsers() {
    // 只读查询操作
}
```


由于项目中缺少Java源代码，无法确认具体实现细节。但从配置文件可以看出，项目已经为多数据源切换做好了基础配置，应该在未公开的Java源代码中实现了相应的切换逻辑。


查看项目根目录结构


**已查看目录** *current project* 5 个结果


查看hq-pro目录结构


**已查看目录** *hq-pro* 7 个结果


查看src目录结构


**已查看目录** *hq-pro/src* 1 个结果


查看src/main目录结构


**已查看目录** *hq-pro/src/main* 2 个结果


查看src/main/java目录结构


**已查看目录** *hq-pro/src/main/java* 1 个结果


查看com目录结构


**已查看目录** *hq-pro/src/main/java/com* 1 个结果


查看o目录结构


**已查看目录** *hq-pro/src/main/java/com/o* 4 个结果


查看project目录结构


**已查看目录** *hq-pro/src/main/java/com/o/project* 6 个结果


查看framework目录结构，可能包含数据源相关代码


**已查看目录** *hq-pro/src/main/java/com/o/framework* 10 个结果


查看datasource目录，很可能包含数据源切换相关代码


**已查看目录** *hq-pro/src/main/java/com/o/framework/datasource* 2 个结果


查看DynamicDataSource.java文件内容


**已查看文件** *DynamicDataSource.java 0-20*


查看DynamicDataSourceContextHolder.java文件内容


**已查看文件** *DynamicDataSourceContextHolder.java 0-50*


查看aspectj目录，可能包含数据源切换的切面代码


**已查看目录** *hq-pro/src/main/java/com/o/framework/aspectj* 4 个结果


查看DataSourceAspect.java文件，这很可能包含数据源切换的切面逻辑


**已查看文件** *DataSourceAspect.java 0-80*


查找DataSource注解相关文件


**已检索文件** *`*DataSource*.java`* 0 个结果


查看config目录，可能包含数据源配置类


**已查看目录** *hq-pro/src/main/java/com/o/framework/config* 17 个结果


查看DruidConfig.java，可能包含Druid数据源配置


**查看文件失败** *DruidConfig.java 0-50*


查看DruidConfig.java，可能包含Druid数据源配置


**已查看文件** *com/o/framework/config/DruidConfig.java 0-50*


查看MyBatisConfig.java，可能包含MyBatis数据源配置


**已查看文件** *com/o/framework/config/MyBatisConfig.java 0-50*


查找可能的数据源枚举类


**已检索文件** *`*DataSource*.java`* 0 个结果


查找可能的注解类


**已检索文件** *`*Target*.java`* 0 个结果


查看aspectj/lang目录


**已查看目录** *hq-pro/src/main/java/com/o/framework/aspectj/lang* 2 个结果


查看annotation目录，可能包含DataSource注解


**已查看目录** *hq-pro/src/main/java/com/o/framework/aspectj/lang/annotation* 5 个结果


查看DataSource注解类


**查看文件失败** *DataSource.java 0-20*


查看DataSource注解类


**已查看文件** *java/com/o/framework/aspectj/lang/annotation/DataSource.java 0-20*
查看enums目录，可能包含数据源类型枚举


**已查看目录** *hq-pro/src/main/java/com/o/framework/aspectj/lang/enums* 4 个结果


查看DataSourceType枚举类


**已查看文件** *java/com/o/framework/aspectj/lang/enums/DataSourceType.java 0-10*


通过查看项目文件结构和部分可读文件内容，我已经找到了该项目实现数据源切换的关键组件。现在我来总结一下这个项目是如何实现数据源切换的：

## 项目数据源切换实现方案

### 1. 核心组件

项目通过以下几个核心组件实现数据源切换：

1. **DataSource注解** (`com.o.framework.aspectj.lang.annotation.DataSource`)
   - 用于标记需要切换数据源的方法或类
   - 指定要使用的数据源类型

2. **DataSourceType枚举** (`com.o.framework.aspectj.lang.enums.DataSourceType`)
   - 定义可用的数据源类型（如MASTER, SLAVE等）

3. **DynamicDataSourceContextHolder** (`com.o.framework.datasource.DynamicDataSourceContextHolder`)
   - 使用ThreadLocal维护当前线程的数据源类型
   - 提供设置和获取当前数据源类型的方法

4. **DynamicDataSource** (`com.o.framework.datasource.DynamicDataSource`)
   - 继承Spring的AbstractRoutingDataSource
   - 实现determineCurrentLookupKey方法，根据当前线程上下文决定使用哪个数据源

5. **DataSourceAspect** (`com.o.framework.aspectj.DataSourceAspect`)
   - AOP切面，拦截带有@DataSource注解的方法
   - 在方法执行前切换数据源，执行后清理数据源设置

### 2. 工作流程

1. 在需要切换数据源的方法或类上添加@DataSource注解，指定数据源类型
2. 当调用这些方法时，DataSourceAspect切面会拦截到这些调用
3. 切面根据注解中指定的数据源类型，通过DynamicDataSourceContextHolder设置当前线程的数据源类型
4. DynamicDataSource在获取连接时，通过determineCurrentLookupKey方法从DynamicDataSourceContextHolder获取当前应该使用的数据源
5. 方法执行完毕后，切面清理当前线程的数据源设置，避免影响后续操作

### 3. 配置方式

项目在[application-dev.yml](file://E:\project\IdeaProjects\hq_study\HCMSELF-CONTROLLER_1.1\hq-pro\src\main\resources\application-dev.yml)中配置了多个数据源：
- master: 主数据源
- slave: 从数据源（默认关闭）
- slave1: 另一个从数据源（默认关闭）

这种实现方式允许在运行时动态切换数据源，特别适用于读写分离场景，可以将写操作路由到主库，读操作路由到从库，从而提高系统性能和可用性。

虽然很多文件内容因加密而无法直接查看，但从文件结构和命名可以清晰地看出这是一个标准的基于Spring Boot和MyBatis的多数据源切换实现方案。









# 配置文件

```
package com.o.framework.config;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.sql.DataSource;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder;
import com.alibaba.druid.spring.boot.autoconfigure.properties.DruidStatProperties;
import com.alibaba.druid.util.Utils;
import com.o.common.utils.spring.SpringUtils;
import com.o.framework.aspectj.lang.enums.DataSourceType;
import com.o.framework.config.properties.DruidProperties;
import com.o.framework.datasource.DynamicDataSource;

/**
 * druid 配置多数据源
 * 
 * @author HQ
 */
@Configuration
public class DruidConfig
{
    @Bean
    @ConfigurationProperties("spring.datasource.druid.master")
    public DataSource masterDataSource(DruidProperties druidProperties)
    {
        DruidDataSource dataSource = DruidDataSourceBuilder.create().build();
        return druidProperties.dataSource(dataSource);
    }

    @Bean
    @ConfigurationProperties("spring.datasource.druid.slave")
    @ConditionalOnProperty(prefix = "spring.datasource.druid.slave", name = "enabled", havingValue = "true")
    public DataSource slaveDataSource(DruidProperties druidProperties)
    {
        DruidDataSource dataSource = DruidDataSourceBuilder.create().build();
        return druidProperties.dataSource(dataSource);
    }

    @Bean
    @ConfigurationProperties("spring.datasource.druid.slave1")
    @ConditionalOnProperty(prefix = "spring.datasource.druid.slave1", name = "enabled", havingValue = "true")
    public DataSource slaveDataSource1(DruidProperties druidProperties)
    {
        DruidDataSource dataSource = DruidDataSourceBuilder.create().build();
        return druidProperties.dataSource(dataSource);
    }

    @Bean(name = "dynamicDataSource")
    @Primary
    public DynamicDataSource dataSource(DataSource masterDataSource)
    {
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put(DataSourceType.MASTER.name(), masterDataSource);
        setDataSource(targetDataSources, DataSourceType.SLAVE.name(), "slaveDataSource");
        setDataSource(targetDataSources, DataSourceType.SLAVE1.name(), "slaveDataSource1");
        return new DynamicDataSource(masterDataSource, targetDataSources);
    }
    
    /**
     * 设置数据源
     * 
     * @param targetDataSources 备选数据源集合
     * @param sourceName 数据源名称
     * @param beanName bean名称
     */
    public void setDataSource(Map<Object, Object> targetDataSources, String sourceName, String beanName)
    {
        try
        {
            DataSource dataSource = SpringUtils.getBean(beanName);
            targetDataSources.put(sourceName, dataSource);
        }
        catch (Exception e)
        {
        }
    }

    /**
     * 去除监控页面底部的广告
     */
    @SuppressWarnings({ "rawtypes", "unchecked" })
    @Bean
    @ConditionalOnProperty(name = "spring.datasource.druid.statViewServlet.enabled", havingValue = "true")
    public FilterRegistrationBean removeDruidFilterRegistrationBean(DruidStatProperties properties)
    {
        // 获取web监控页面的参数
        DruidStatProperties.StatViewServlet config = properties.getStatViewServlet();
        // 提取common.js的配置路径
        String pattern = config.getUrlPattern() != null ? config.getUrlPattern() : "/druid/*";
        String commonJsPattern = pattern.replaceAll("\\*", "js/common.js");
        final String filePath = "support/http/resources/js/common.js";
        // 创建filter进行过滤
        Filter filter = new Filter()
        {
            @Override
            public void init(javax.servlet.FilterConfig filterConfig) throws ServletException
            {
            }
            @Override
            public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
                    throws IOException, ServletException
            {
                chain.doFilter(request, response);
                // 重置缓冲区，响应头不会被重置
                response.resetBuffer();
                // 获取common.js
                String text = Utils.readFromResource(filePath);
                // 正则替换banner, 除去底部的广告信息
                text = text.replaceAll("<a.*?banner\"></a><br/>", "");
                text = text.replaceAll("powered.*?shrek.wang</a>", "");
                response.getWriter().write(text);
            }
            @Override
            public void destroy()
            {
            }
        };
        FilterRegistrationBean registrationBean = new FilterRegistrationBean();
        registrationBean.setFilter(filter);
        registrationBean.addUrlPatterns(commonJsPattern);
        return registrationBean;
    }
}
```

这段代码是一个基于 **Spring Boot + Druid** 的多数据源配置类，主要实现以下功能：

---

### **1. 核心功能**
#### **（1）配置多数据源**
- **主数据源（Master）**：  
  - 通过 `masterDataSource()` 方法创建，绑定 `spring.datasource.druid.master` 配置项（如JDBC URL、用户名、密码等）。
  - 始终启用，作为默认数据源。
- **从数据源（Slave/Slave1）**：  
  - 通过 `slaveDataSource()` 和 `slaveDataSource1()` 方法创建，分别绑定 `spring.datasource.druid.slave` 和 `spring.datasource.druid.slave1` 配置。
  - **条件启用**：仅在配置中设置 `enabled: true` 时才会初始化（通过 `@ConditionalOnProperty` 控制）。

#### **（2）动态数据源路由**
- **`DynamicDataSource`**：  
  - 通过 `dataSource()` 方法创建，组合主从数据源（`targetDataSources`）。
  - 使用 `@Primary` 标记为默认数据源，实际运行时根据逻辑动态切换（需配合AOP或手动指定数据源类型，如 `DataSourceType.MASTER`/`SLAVE`）。

#### **（3）从容器中动态加载数据源**
- `setDataSource()` 方法通过 `SpringUtils.getBean()` 动态获取从数据源Bean（避免直接注入的循环依赖问题），并添加到目标数据源映射中。

---

### **2. 辅助功能**
#### **（1）Druid监控页面广告移除**
- **问题**：Druid自带的监控页面底部有广告。
- **解决方案**：  
  - 注册一个过滤器（`removeDruidFilterRegistrationBean`），拦截对 `common.js` 的请求。  
  - 通过正则表达式替换掉广告相关的HTML内容（如 `<a.*?banner\"></a><br/>`）。  
  - 仅当配置 `spring.datasource.druid.statViewServlet.enabled=true` 时生效。

---

### **3. 关键注解说明**
| 注解                          | 作用                                                                 |
|-------------------------------|----------------------------------------------------------------------|
| `@Configuration`              | 声明这是一个Spring配置类。                                           |
| `@Bean`                       | 将方法返回的对象注册为Spring Bean。                                   |
| `@ConfigurationProperties`    | 绑定配置文件中的属性到Bean（如 `spring.datasource.druid.master`）。   |
| `@ConditionalOnProperty`      | 根据配置条件决定是否创建Bean（如从数据源的启用开关）。                |
| `@Primary`                    | 标记默认数据源，解决多个同类型Bean的注入冲突。                        |

---

### **4. 使用场景**
- **读写分离**：主库写，从库读。
- **多租户数据隔离**：不同租户使用不同数据源。
- **分库分表**：通过动态数据源路由到不同的物理库。

---

### **5. 注意事项**
1. **从数据源的可选性**：  
   Slave和Slave1数据源需要显式配置 `enabled: true` 才会启用。
2. **动态切换实现**：  
   需结合AOP或注解（如 `@DataSource(DataSourceType.SLAVE)`）在Service层切换数据源。
3. **Druid监控安全**：  
   生产环境应限制监控页面的访问权限（代码中未体现，需额外配置）。

如果需要扩展（如增加更多从数据源或自定义路由策略），可以基于此模板继续完善。


# 为什么上面的数据源配置中，主数据源和从数据源添加到targetDataSources的方式不一样

在提供的代码中，**主数据源（Master）和从数据源（Slave/Slave1）添加到 `targetDataSources` 的方式确实不同**，这是由两者的设计意图和运行机制决定的。以下是具体原因和逻辑分析：

---

### **1. 主数据源（Master）的添加方式**
#### **代码行为**：
```java
@Primary
public DynamicDataSource dataSource(DataSource masterDataSource) {
    Map<Object, Object> targetDataSources = new HashMap<>();
    targetDataSources.put(DataSourceType.MASTER.name(), masterDataSource); // 直接注入
    // 从数据源通过 setDataSource 方法动态添加
}
```
#### **原因**：
- **主数据源是必须存在的**：  
  作为默认数据源（`@Primary`），它必须在应用启动时 **直接初始化并注入**，否则系统无法运行。
- **强依赖关系**：  
  `DynamicDataSource` 的构造函数需要至少一个主数据源作为后备数据源（fallback），因此直接通过方法参数注入。

---

### **2. 从数据源（Slave/Slave1）的添加方式**
#### **代码行为**：
```java
setDataSource(targetDataSources, DataSourceType.SLAVE.name(), "slaveDataSource");
setDataSource(targetDataSources, DataSourceType.SLAVE1.name(), "slaveDataSource1");

// 动态从Spring容器获取Bean
public void setDataSource(Map<Object, Object> targetDataSources, String sourceName, String beanName) {
    try {
        DataSource dataSource = SpringUtils.getBean(beanName);
        targetDataSources.put(sourceName, dataSource);
    } catch (Exception e) {
        // 忽略异常（从数据源可选）
    }
}
```
#### **原因**：
- **从数据源是条件化的**：  
  通过 `@ConditionalOnProperty` 控制是否启用（如 `slave.enabled=true`）。如果配置未启用，对应的Bean不会存在于Spring容器中。
- **动态加载避免启动失败**：  
  如果直接通过方法参数注入（如 `slaveDataSource`），当从数据源未启用时，Spring会因找不到Bean而抛出异常。通过 `SpringUtils.getBean()` 动态获取可以 **优雅处理可选依赖**。
- **灵活性**：  
  支持运行时动态增减数据源（例如热部署场景），而主数据源通常是固定的。

---

### **3. 设计意图对比**
| **数据源类型** | **添加方式**               | **目的**                                                                 |
|----------------|---------------------------|-------------------------------------------------------------------------|
| 主数据源       | 直接注入                  | 确保系统必须有至少一个可用的数据源，避免启动失败。                        |
| 从数据源       | 动态从容器获取            | 支持条件化启用/禁用，避免强依赖导致启动失败，增强灵活性。                 |

---

### **4. 潜在问题与改进建议**
#### **问题**：
- 如果从数据源的Bean名称（如 `"slaveDataSource"`）拼写错误，`getBean()` 会静默失败（捕获异常但未日志记录），导致数据源未正确加载。
#### **改进**：
```java
public void setDataSource(Map<Object, Object> targetDataSources, String sourceName, String beanName) {
    try {
        DataSource dataSource = SpringUtils.getBean(beanName);
        targetDataSources.put(sourceName, dataSource);
    } catch (Exception e) {
        // 记录警告日志，便于排查问题
        logger.warn("Failed to load data source [{}]: {}", beanName, e.getMessage());
    }
}
```

---

### **5. 总结**
- **主数据源直接注入**：保证系统基础功能可用，符合 `@Primary` 的设计原则。  
- **从数据源动态加载**：适应条件化配置和可选依赖的需求，提升灵活性。  
- **本质区别**：主数据源是 **强依赖**，从数据源是 **弱依赖**。这种差异化的处理是典型的框架设计模式，兼顾了鲁棒性和扩展性。







# return new DynamicDataSource(masterDataSource, targetDataSources);为什么第一个参数中已经有master了，但是后面的tager还要再添加master数据源，这个返回出去的效果是什么，为什么需要两个参数




在 `DynamicDataSource` 的构造函数中，**第一个参数 `masterDataSource` 和 `targetDataSources` 中重复添加 Master 数据源**，这种设计是为了实现以下两个关键目标：

---

### **1. 设计意图解析**
#### **（1）第一个参数 `masterDataSource` 的作用**
- **默认后备数据源（Fallback）**：  
  当动态数据源（`DynamicDataSource`）无法通过路由键（如 `DataSourceType.MASTER.name()`）从 `targetDataSources` 中找到匹配的数据源时，会自动回退到 `masterDataSource`。  
  - 这是一种 **防御性编程**，确保系统始终有一个可用的数据源，避免因路由错误导致空指针异常。

#### **（2）`targetDataSources` 中包含 Master 的原因**
- **统一路由管理**：  
  将所有数据源（包括 Master）存入 `targetDataSources`，可以通过 **一致的键（如 `MASTER`）** 动态切换到主库。例如：
  ```java
  DynamicDataSourceContextHolder.setDataSourceType(DataSourceType.MASTER.name()); // 显式切换到主库
  ```
- **逻辑对称性**：  
  从代码可读性角度看，Master 和 Slave 数据源以相同方式存储在 `Map` 中，便于维护和扩展。

---

### **2. 实际效果示例**
假设构造函数调用如下：
```java
return new DynamicDataSource(masterDataSource, targetDataSources);
```
其中 `targetDataSources` 包含：
```java
{
    "MASTER": masterDataSource,
    "SLAVE": slaveDataSource,
    "SLAVE1": slaveDataSource1
}
```

#### **运行时行为**：
1. **显式切换数据源**：  
   - 调用 `DynamicDataSourceContextHolder.setDataSourceType("MASTER")` 时，会从 `targetDataSources` 中取出 `masterDataSource`。  
   - 调用 `setDataSourceType("SLAVE")` 时，取出 `slaveDataSource`。

2. **未指定数据源或键不存在时**：  
   - 若未设置路由键（或键不存在），则自动使用构造函数传入的 `masterDataSource` 作为默认数据源。

---

### **3. 为什么需要两个参数？**
| **参数**              | **必要性**                                                                 | **替代方案对比**                                                                 |
|-----------------------|--------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| `masterDataSource`    | 确保绝对有一个可用的默认数据源，即使 `targetDataSources` 为空或路由失败。       | 如果仅依赖 `targetDataSources`，需在每次路由时判空，代码冗余且易出错。                  |
| `targetDataSources`   | 支持动态路由到任意数据源（包括 Master），实现灵活切换。                        | 如果仅用 `masterDataSource`，无法实现多数据源动态切换（如读写分离）。                   |

---

### **4. 典型应用场景**
#### **场景 1：读写分离**
- 写操作：  
  ```java
  DynamicDataSourceContextHolder.setDataSourceType("MASTER"); // 显式指定主库
  ```
- 读操作：  
  ```java
  DynamicDataSourceContextHolder.setDataSourceType("SLAVE"); // 切换到从库
  ```

#### **场景 2：故障降级**
- 当从库不可用时，不设置路由键（或捕获异常后清除键），自动回退到主库。

---

### **5. 源码设计类比**
这种设计与 Spring 的 `@Primary` 注解逻辑类似：
- `@Primary` 标记默认 Bean，但其他 Bean 仍可通过名称或限定符注入。  
- `DynamicDataSource` 的 `masterDataSource` 是隐式的 `@Primary`，而 `targetDataSources` 支持显式选择。

---

### **6. 总结**
- **双重保障**：`masterDataSource` 是底线，`targetDataSources` 是扩展。  
- **灵活性与鲁棒性**：既支持动态路由，又避免因配置错误导致系统不可用。  
- **常见于开源框架**：如 MyBatis 的 `AbstractRoutingDataSource` 也采用类似设计。

如果需要进一步优化，可以考虑：
1. 在 `targetDataSources` 判空时记录告警日志。  
2. 通过注解（如 `@DS("master")`）简化路由键管理。


# determineCurrentLookupKey()这个重写的方法为什么我没有在idea中看到在哪调用的

在 `DynamicDataSource` 类中，你重写的 `determineCurrentLookupKey()` 方法并不是由你直接调用的，而是由 **Spring 框架**在运行时通过父类 `AbstractRoutingDataSource` 的底层机制自动触发的。以下是详细解释：

---

### **1. 方法调用时机**
`determineCurrentLookupKey()` 的调用发生在 **每次数据库操作（如执行SQL）前**，具体流程如下：
1. 当你的代码通过 Spring JDBC、MyBatis 等执行数据库操作时（例如调用 `JdbcTemplate` 或 Mapper 方法）。
2. Spring 会通过 `DataSource` 获取数据库连接（`Connection`）。
3. 此时父类 `AbstractRoutingDataSource` 的 `getConnection()` 方法会被调用，其内部会 **自动触发** `determineCurrentLookupKey()` 来决定当前使用哪个数据源。

---

### **2. 为什么在 IDEA 中看不到直接调用？**
- **框架内部调用**：  
  `determineCurrentLookupKey()` 是 Spring 设计的一个 **回调方法（Hook）**，由 `AbstractRoutingDataSource` 在底层调用，而不是你的业务代码直接调用。
- **调用栈示例**：  
  你可以在调试时设置断点，观察调用栈（Call Stack）：
  ```
  getConnection() → AbstractRoutingDataSource.resolveSpecifiedLookupKey() → determineCurrentLookupKey()
  ```

---

### **3. 关键源码分析**
父类 `AbstractRoutingDataSource` 的核心逻辑（简化版）：
```java
public Connection getConnection() throws SQLException {
    // 1. 调用你的 determineCurrentLookupKey() 获取当前数据源键
    Object lookupKey = determineCurrentLookupKey();
    // 2. 根据键从 targetDataSources 中获取具体数据源
    DataSource dataSource = resolveSpecifiedDataSource(lookupKey);
    // 3. 返回连接
    return dataSource.getConnection();
}
```

---

### **4. 动态切换的实现**
- **`DynamicDataSourceContextHolder`**：  
  你通过 `DynamicDataSourceContextHolder.setDataSourceType("MASTER")` 设置的值，会在 `determineCurrentLookupKey()` 中被读取：
  ```java
  protected Object determineCurrentLookupKey() {
      return DynamicDataSourceContextHolder.getDataSourceType(); // 返回当前线程绑定的数据源键
  }
  ```
- **线程隔离**：  
  `DynamicDataSourceContextHolder` 通常使用 `ThreadLocal` 存储键值，确保每个线程独立切换数据源（避免多线程冲突）。

---

### **5. 验证方法**
如果仍不确定是否生效，可以通过以下方式验证：
#### **(1) 调试断点**
在 `determineCurrentLookupKey()` 方法内打断点，执行数据库操作时观察是否触发。

#### **(2) 日志输出**
临时添加日志：
```java
@Override
protected Object determineCurrentLookupKey() {
    String key = DynamicDataSourceContextHolder.getDataSourceType();
    logger.debug("当前数据源键: {}", key); // 观察日志输出
    return key;
}
```

#### **(3) 查看调用栈**
在调试模式下，检查调用栈来源（通常来自 `DataSourceUtils.getConnection()` 或 MyBatis 的 `SqlSession`）。

---

### **6. 总结**
- **隐式调用**：`determineCurrentLookupKey()` 是 Spring 框架的回调方法，由 `AbstractRoutingDataSource` 在获取连接时自动触发。
- **设计模式**：这是 **模板方法模式** 的典型应用，父类定义流程，子类实现具体逻辑。
- **无需手动调用**：你只需要通过 `DynamicDataSourceContextHolder` 设置路由键，剩余工作由 Spring 完成。

如果仍不生效，请检查：
1. `DynamicDataSource` 是否被正确注入为 Spring Bean。
2. `DynamicDataSourceContextHolder` 的键值是否在调用 SQL 前正确设置。
3. 是否有多线程污染（如异步场景未正确传递上下文）。




![](assets/Pasted%20image%2020250724185334.png)



![](assets/Pasted%20image%2020250724185956.png)



# 总结

1. **自定义注解方式**：通过在方法或类上添加 `@DataSource` 注解指定要使用的数据源
2. **AOP切面处理**：通过切面拦截注解，动态切换数据源 设置threadlocal变量
3. **ThreadLocal存储**：使用ThreadLocal存储当前线程使用的数据源标识
4. **动态数据源类**：继承 `AbstractRoutingDataSource` 实现 `determineCurrentLookupKey()` 方法

过程：
扫描到注解
出发aop切面编程设置threadlocal变量
然后sql语句进行查询之前，会触发选择数据源的那个重写方法，那个重写方法又从threadlocal中获取对应数据库的键值然后从返回的bean（return new DynamicDataSource(masterDataSource, targetDataSources);）里面找那个数据源

先从targetdatasources找应该是
找不到退回默认数据源masterdatasource
target里面是map结构，所以能按照键找值 名字-datasource


# 所涉及的文件
![](assets/Pasted%20image%2020250724191750.png)


```
package com.o.framework.aspectj.lang.annotation;  
  
import java.lang.annotation.Documented;  
import java.lang.annotation.ElementType;  
import java.lang.annotation.Inherited;  
import java.lang.annotation.Retention;  
import java.lang.annotation.RetentionPolicy;  
import java.lang.annotation.Target;  
import com.o.framework.aspectj.lang.enums.DataSourceType;  
  
/**  
 * 自定义多数据源切换注解  
 *  
 * 优先级：先方法，后类，如果方法覆盖了类上的数据源类型，以方法的为准，否则以类上的为准  
 *  
 * @author HQ  
 */@Target({ ElementType.METHOD, ElementType.TYPE })  
@Retention(RetentionPolicy.RUNTIME)  
@Documented  
@Inherited  
public @interface DataSource  
{  
    /**  
     * 切换数据源名称  
     */  
    public DataSourceType value() default DataSourceType.MASTER;  
}
```

```
package com.o.framework.aspectj;  
  
import java.util.Objects;  
import org.aspectj.lang.ProceedingJoinPoint;  
import org.aspectj.lang.annotation.Around;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.annotation.Pointcut;  
import org.aspectj.lang.reflect.MethodSignature;  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
import org.springframework.core.annotation.AnnotationUtils;  
import org.springframework.core.annotation.Order;  
import org.springframework.stereotype.Component;  
import com.o.common.utils.StringUtils;  
import com.o.framework.aspectj.lang.annotation.DataSource;  
import com.o.framework.datasource.DynamicDataSourceContextHolder;  
  
/**  
 * 多数据源处理  
 *   
* @author HQ  
 */@Aspect  
@Order(1)  
@Component  
public class DataSourceAspect  
{  
    protected Logger logger = LoggerFactory.getLogger(getClass());  
  
    @Pointcut("@annotation(com.o.framework.aspectj.lang.annotation.DataSource)"  
            + "|| @within(com.o.framework.aspectj.lang.annotation.DataSource)")  
    public void dsPointCut()  
    {  
  
    }  
  
    @Around("dsPointCut()")  
    public Object around(ProceedingJoinPoint point) throws Throwable  
    {  
        DataSource dataSource = getDataSource(point);  
  
        if (StringUtils.isNotNull(dataSource))  
        {  
            DynamicDataSourceContextHolder.setDataSourceType(dataSource.value().name());  
        }  
  
        try  
        {  
            return point.proceed();  
        }  
        finally  
        {  
            // 销毁数据源 在执行方法之后  
            DynamicDataSourceContextHolder.clearDataSourceType();  
        }  
    }  
  
    /**  
     * 获取需要切换的数据源  
     */  
    public DataSource getDataSource(ProceedingJoinPoint point)  
    {  
        MethodSignature signature = (MethodSignature) point.getSignature();  
        DataSource dataSource = AnnotationUtils.findAnnotation(signature.getMethod(), DataSource.class);  
//        logger.info("切换数据源的方法："+signature.getMethod()+"方法上的注解数据源："+dataSource);  
        if (Objects.nonNull(dataSource))  
        {  
            return dataSource;  
        }  
//        logger.info(signature.getDeclaringType()+"类上的注解数据源："+AnnotationUtils.findAnnotation(signature.getDeclaringType(), DataSource.class));  
        return AnnotationUtils.findAnnotation(signature.getDeclaringType(), DataSource.class);  
    }  
}
```

```
package com.o.framework.datasource;  
  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
  
/**  
 * 数据源切换处理  
 *  
 * @author HQ  
 */public class DynamicDataSourceContextHolder  
{  
    public static final Logger log = LoggerFactory.getLogger(DynamicDataSourceContextHolder.class);  
  
    /**  
     * 使用ThreadLocal维护变量，ThreadLocal为每个使用该变量的线程提供独立的变量副本，  
     *  所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。  
     */  
    private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();  
  
    /**  
     * 设置数据源的变量  
     */  
    public static void setDataSourceType(String dsType)  
    {  
//        log.info("切换到{}数据源", dsType);  
        CONTEXT_HOLDER.set(dsType);  
    }  
  
    /**  
     * 获得数据源的变量  
     */  
    public static String getDataSourceType()  
    {  
        return CONTEXT_HOLDER.get();  
    }  
  
    /**  
     * 清空数据源变量  
     */  
    public static void clearDataSourceType()  
    {  
        CONTEXT_HOLDER.remove();  
    }  
}
```

```
package com.o.framework.aspectj.lang.enums;  
  
/**  
 * 数据源  
 *   
* @author HQ  
 */public enum DataSourceType  
{  
    /**  
     * 主库 自助本身  
     */  
    MASTER,  
  
    /**  
     * 从库 hcm  
     */    SLAVE,  
    /**  
     * 从库 oa  
     */    SLAVE1  
}
```

```
package com.o.framework.config;  
  
import java.io.IOException;  
import java.util.HashMap;  
import java.util.Map;  
import javax.servlet.Filter;  
import javax.servlet.FilterChain;  
import javax.servlet.ServletException;  
import javax.servlet.ServletRequest;  
import javax.servlet.ServletResponse;  
import javax.sql.DataSource;  
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;  
import org.springframework.boot.context.properties.ConfigurationProperties;  
import org.springframework.boot.web.servlet.FilterRegistrationBean;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.context.annotation.Primary;  
import com.alibaba.druid.pool.DruidDataSource;  
import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder;  
import com.alibaba.druid.spring.boot.autoconfigure.properties.DruidStatProperties;  
import com.alibaba.druid.util.Utils;  
import com.o.common.utils.spring.SpringUtils;  
import com.o.framework.aspectj.lang.enums.DataSourceType;  
import com.o.framework.config.properties.DruidProperties;  
import com.o.framework.datasource.DynamicDataSource;  
  
/**  
 * druid 配置多数据源  
 *   
* @author HQ  
 */@Configuration  
public class DruidConfig  
{  
    @Bean  
    @ConfigurationProperties("spring.datasource.druid.master")  
    public DataSource masterDataSource(DruidProperties druidProperties)  
    {  
        DruidDataSource dataSource = DruidDataSourceBuilder.create().build();  
        return druidProperties.dataSource(dataSource);  
    }  
  
    @Bean  
    @ConfigurationProperties("spring.datasource.druid.slave")  
    @ConditionalOnProperty(prefix = "spring.datasource.druid.slave", name = "enabled", havingValue = "true")  
    public DataSource slaveDataSource(DruidProperties druidProperties)  
    {  
        DruidDataSource dataSource = DruidDataSourceBuilder.create().build();  
        return druidProperties.dataSource(dataSource);  
    }  
  
    @Bean  
    @ConfigurationProperties("spring.datasource.druid.slave1")  
    @ConditionalOnProperty(prefix = "spring.datasource.druid.slave1", name = "enabled", havingValue = "true")  
    public DataSource slaveDataSource1(DruidProperties druidProperties)  
    {  
        DruidDataSource dataSource = DruidDataSourceBuilder.create().build();  
        return druidProperties.dataSource(dataSource);  
    }  
  
    @Bean(name = "dynamicDataSource")  
    @Primary  
    public DynamicDataSource dataSource(DataSource masterDataSource)  
    {  
        Map<Object, Object> targetDataSources = new HashMap<>();  
        targetDataSources.put(DataSourceType.MASTER.name(), masterDataSource);  
        /*因为这俩数据源不一定有，所以要手动获取bean添加的意思？*/  
        setDataSource(targetDataSources, DataSourceType.SLAVE.name(), "slaveDataSource");  
        setDataSource(targetDataSources, DataSourceType.SLAVE1.name(), "slaveDataSource1");  
        return new DynamicDataSource(masterDataSource, targetDataSources);  
    }  
      
    /**  
     * 设置数据源  
     *   
* @param targetDataSources 备选数据源集合  
     * @param sourceName 数据源名称  
     * @param beanName bean名称  
     */  
    public void setDataSource(Map<Object, Object> targetDataSources, String sourceName, String beanName)  
    {  
        try  
        {  
            DataSource dataSource = SpringUtils.getBean(beanName);  
            targetDataSources.put(sourceName, dataSource);  
        }  
        catch (Exception e)  
        {  
        }  
    }  
  
    /**  
     * 去除监控页面底部的广告  
     */  
    @SuppressWarnings({ "rawtypes", "unchecked" })  
    @Bean  
    @ConditionalOnProperty(name = "spring.datasource.druid.statViewServlet.enabled", havingValue = "true")  
    public FilterRegistrationBean removeDruidFilterRegistrationBean(DruidStatProperties properties)  
    {  
        // 获取web监控页面的参数  
        DruidStatProperties.StatViewServlet config = properties.getStatViewServlet();  
        // 提取common.js的配置路径  
        String pattern = config.getUrlPattern() != null ? config.getUrlPattern() : "/druid/*";  
        String commonJsPattern = pattern.replaceAll("\\*", "js/common.js");  
        final String filePath = "support/http/resources/js/common.js";  
        // 创建filter进行过滤  
        Filter filter = new Filter()  
        {  
            @Override  
            public void init(javax.servlet.FilterConfig filterConfig) throws ServletException  
            {  
            }  
            @Override  
            public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)  
                    throws IOException, ServletException  
            {  
                chain.doFilter(request, response);  
                // 重置缓冲区，响应头不会被重置  
                response.resetBuffer();  
                // 获取common.js  
                String text = Utils.readFromResource(filePath);  
                // 正则替换banner, 除去底部的广告信息  
                text = text.replaceAll("<a.*?banner\"></a><br/>", "");  
                text = text.replaceAll("powered.*?shrek.wang</a>", "");  
                response.getWriter().write(text);  
            }  
            @Override  
            public void destroy()  
            {  
            }  
        };  
        FilterRegistrationBean registrationBean = new FilterRegistrationBean();  
        registrationBean.setFilter(filter);  
        registrationBean.addUrlPatterns(commonJsPattern);  
        return registrationBean;  
    }  
}
```

```
package com.o.framework.datasource;  
  
import java.util.Map;  
import javax.sql.DataSource;  
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;  
  
/**  
 * 动态数据源  
 *   
* @author HQ  
 */public class DynamicDataSource extends AbstractRoutingDataSource  
{  
    public DynamicDataSource(DataSource defaultTargetDataSource, Map<Object, Object> targetDataSources)  
    {  
        super.setDefaultTargetDataSource(defaultTargetDataSource);  
        super.setTargetDataSources(targetDataSources);  
        super.afterPropertiesSet();  
    }  
  
    @Override  
    protected Object determineCurrentLookupKey()  
    {  
        return DynamicDataSourceContextHolder.getDataSourceType();  
    }  
}
```
## 配置文件
![](assets/Pasted%20image%2020250724192127.png)