# begin


# src/main/java/com/o/project/manager/service/impl/TbOrgUnitServiceImpl.java里面selectTbOrgUnitByOrgAndUser函数详解
这个方法就是那个根据用户id和组织id查询对应的什么组织单元信息，然后进行set，然后进行后续的分析过程。

下面是对 `selectTbOrgUnitByOrgAndUser` 方法的详细解释，结合你的代码上下文进行逐段分析：

---

### 📌 方法签名

```java
public TbOrgUnit selectTbOrgUnitByOrgAndUser(String orgId, String userCode)
```


- **作用**：根据传入的组织 ID 和用户工号，查询该用户的主职组织信息（包含层级 `level` 和属性 [properties](file://E:\project\IdeaProjects\hq\HCMSELF-CONTROLLER_1.1\hq-pro\target\classes\META-INF\app.properties)）。
- **参数说明**：
  - `orgId`: 组织的唯一标识（可能为空）；
  - `userCode`: 用户工号（不能为空）。

---

### 🧱 方法逻辑详解

#### ✅ 第一步：空值校验
```java
if(StringUtils.isEmpty(userCode)){
    throw new CustomException(MessageUtils.message("system.deserted.exception"));
}
```

- 如果 `userCode` 为空，则抛出异常，提示“系统废弃异常”。
- 这是保证方法核心参数必须存在，否则无法继续执行。

---

#### ✅ 第二步：处理 `orgId` 为空的情况
```java
if((StringUtils.isEmpty(orgId) || "null".equalsIgnoreCase(orgId))){
```

- 判断传入的 `orgId` 是否为空或 `"null"` 字符串。

##### 🔍 注释说明：
> “组织hid传过来是空，人员信息非空，先默认获取主职的组织信息，以减少95%非兼岗人员的报错问题，此方法会对兼岗的有所影响，兼岗场景不知道所选组织id，可能会导致数据混乱”

- 表示这个判断主要是为了兼容大多数非兼岗人员的情况，避免频繁报错；
- 兼岗（多岗位）场景下，由于没有明确指定组织 ID，可能会导致数据不准确。

##### 🔁 查询主职组织信息
```java
List<TbOrgUnit> tbOrgUnits = new ArrayList<>();
if("101000001".equals(userCode)){
    tbOrgUnits = this.selectLeaderPosDeptByUserCode(userCode, CEO);
}else {
    tbOrgUnits = this.selectLeaderPosDeptByUserCode(userCode, "");
}
tbOrgUnit = !CollectionUtil.isEmpty(tbOrgUnits) ? tbOrgUnits.get(0) : null;
```

- 根据 `userCode` 查询用户的主管组织信息（主职）；
- 若为特殊用户（如CEO），调用特定方法 `selectLeaderPosDeptByUserCode(...)` 并传递参数区分；
- 否则使用通用方法查询；
- 取第一个结果作为当前组织信息。

---

#### ✅ 第三步：处理 `orgId` 不为空的情况
```java
else {
    tbOrgUnit = tbOrgUnitMapper.selectTbOrgUnitInfoByOrgId(orgId);
    log.info("根据组织id获取当前人的主管组织信息，组织hid："+orgId+ "返回的组织Object:"+(ObjectUtil.isEmpty(tbOrgUnit) ? tbOrgUnit : "层级"+tbOrgUnit.getLevel()+"属性"+tbOrgUnit.getProperties()));
}
```

- 如果 `orgId` 存在，则直接通过数据库 Mapper 查询对应的组织信息；
- 调用了 `tbOrgUnitMapper.selectTbOrgUnitInfoByOrgId(orgId)`。

---

#### ✅ 第四步：组织信息为空时抛出异常
```java
if (tbOrgUnit == null || StringUtils.isEmpty(tbOrgUnit.getLevel())) {
    log.info("根据组织hid获取组织关键信息orgId:"+orgId+"工号："+userCode+"响应：该组织或组织层级不存在"+ (ObjectUtil.isEmpty(tbOrgUnit) ? tbOrgUnit : "层级"+tbOrgUnit.getLevel()+"属性"+tbOrgUnit.getProperties()));
    throw new CustomException(MessageUtils.message("system.deserted.exception"));
}
```

- 如果最终获取到的 `tbOrgUnit` 为空 或者其 `level` 属性为空，则抛出异常；
- 表示组织信息无效或缺失层级信息，无法继续后续操作。

---

#### ✅ 第五步：默认设置组织属性
```java
if(StringUtils.isEmpty(tbOrgUnit.getProperties())){
    tbOrgUnit.setProperties("1");
}
```

- 如果 [properties](file://E:\project\IdeaProjects\hq\HCMSELF-CONTROLLER_1.1\hq-pro\target\classes\META-INF\app.properties) 为空，默认赋值为 `"1"`；
- 表示默认组织属性为非制造类组织。

---

### 📋 总结流程图（伪代码）

```plaintext
开始
│
├── 校验 userCode 是否为空
│   └── 是 → 抛出异常
│
├── 判断 orgId 是否为空
│   └── 是 → 查询用户的主职组织信息（优先取第一个）
│       ├── 特殊用户（如CEO）→ 指定参数查询
│       └── 普通用户 → 通用查询
│
│   └── 否 → 根据 orgId 查询组织信息
│
├── 判断查询结果是否为空或缺少 level
│   └── 是 → 抛出异常
│
└── 设置默认 properties（若为空）
    └── 默认值："1"
```


---

### 💡 业务意义

- **主要目的**：确保系统中每个用户都能正确获取到自己的组织信息（尤其是层级和属性字段）；
- **设计考虑**：
  - 非兼岗用户占多数，所以优先按用户查主职组织；
  - 兼岗用户需传入 `orgId` 才能精准定位；
  - 提供默认值避免程序因空值崩溃；
- **潜在风险**：
  - 兼岗用户未传 `orgId`，可能导致数据不准；
  - 主职组织可能不是当前用户期望的组织。

---

### 🧩 依赖的方法说明

| 方法名 | 功能 |
|--------|------|
| `selectLeaderPosDeptByUserCode(userCode, flag)` | 查询用户的主职组织信息，可带标志位区分特殊角色（如CEO） |
| `tbOrgUnitMapper.selectTbOrgUnitInfoByOrgId(orgId)` | 根据组织ID从数据库中查询组织信息 |

---

### ✅ 返回值

- 返回一个 `TbOrgUnit` 对象，包含：
  - 组织层级（`level`）；
  - 组织属性（[properties](file://E:\project\IdeaProjects\hq\HCMSELF-CONTROLLER_1.1\hq-pro\target\classes\META-INF\app.properties)）；
  - 其他组织相关信息。

---

### 📌 最终用途

该方法主要用于登录、权限控制、组织架构展示等需要用户当前所属组织信息的场景，是基础支撑服务之一。





# 实现类里面的selectLeaderPosDeptByUserCode


这个方法 `selectLeaderPosDeptByUserCode` 是用于根据员工工号（`empCode`）和岗位名称（`postName`）查询该人员所主管的组织信息列表（`List<TbOrgUnit>`）。其中，特别处理了岗位是 CEO 的情况。

---

### 📌 方法签名

```java
public List<TbOrgUnit> selectLeaderPosDeptByUserCode(String empCode, String postName)
```


- **作用**：获取某位员工在主管岗位下的所属组织信息；
- **参数说明**：
  - `empCode`: 员工工号；
  - `postName`: 岗位名称（如“CEO”、“总裁室”等）；

---

### 🧱 方法逻辑详解

#### ✅ 第一步：判断是否为 CEO 岗位

```java
if (CEO.equals(postName)) {
    TbOrgUnit tbOrgUnit = tbOrgUnitMapper.selectTbOrgUnitInfoByOrgId("6042d4ad0d654ddf819926f023b4d968");
    List<TbOrgUnit> tbOrgUnitList = new ArrayList<>();
    tbOrgUnitList.add(tbOrgUnit);
    return tbOrgUnitList;
}
```


##### 🔍 注释说明：
> “如果岗位为‘CEO’，则默认对应组织为‘华勤技术股份有限公司’，而非‘总裁室’”

- 如果传入的岗位名是 `"CEO"`，则直接返回一个预设的组织信息，组织 ID 是 `"6042d4ad0d654ddf819926f023b4d968"`。
- 即使数据库中可能有多个与“CEO”相关的组织，也只返回这个特定的组织。
- 返回的是一个包含单个组织对象的列表 `List<TbOrgUnit>`。

---

#### ✅ 第二步：非 CEO 情况下的通用查询

```java
List<TbOrgUnit> tbOrgUnitList = tbOrgUnitMapper.selectLeaderPosDeptByUserCode(empCode);
```


- 调用 Mapper 层的方法，通过员工工号 `empCode` 查询其主管岗位对应的组织信息列表；
- 数据来自数据库，且组织属性（[properties](file://E:\project\IdeaProjects\hq\HCMSELF-CONTROLLER_1.1\hq-pro\target\classes\META-INF\app.properties)）已经在 SQL 中进行了追溯。

---

#### ✅ 第三步：日志记录与空值补全

```java
log.info("根据员工工号"+empCode+"获取主管岗位的组织列表的List返回长度："+tbOrgUnitList.size());
tbOrgUnitList.forEach(e -> {
    if (StringUtils.isEmpty(e.getProperties())) {
        e.setProperties("1");
    }
});
```


- 输出日志记录返回的组织数量；
- 遍历列表，若某个组织的 `properties` 字段为空，则设置默认值 `"1"`，表示“非制造类组织”。

---

### 📋 总结流程图（伪代码）

```plaintext
开始
│
├── 判断 postName 是否等于 "CEO"
│   └── 是 → 固定返回组织ID为"6042d4ad0d654ddf819926f023b4d968"的组织信息
│
│   └── 否 → 调用 Mapper 查询该员工的主管组织列表
│           ├── 记录日志：返回结果的数量
│           └── 遍历列表，将 properties 为空的字段设置为默认值 "1"
│
└── 返回组织信息列表 List<TbOrgUnit>
```


---

### 💡 业务意义

- **特殊处理 CEO**：
  - CEO 在系统中通常属于一个特殊的组织架构层级，为了避免因不同数据源或兼岗问题导致的数据混乱，系统做了硬编码处理，直接指向一个固定的组织（例如“华勤技术股份有限公司”）；
  - 这样可以确保无论数据库中如何配置，CEO 的组织信息始终稳定、准确。
  
- **统一组织属性**：
  - 若某些组织的 [properties](file://E:\project\IdeaProjects\hq\HCMSELF-CONTROLLER_1.1\hq-pro\target\classes\META-INF\app.properties) 字段缺失，默认赋值为 `"1"`，避免后续业务逻辑中因空值出错；
  - `"1"` 表示“非制造类组织”，这是一个业务定义的标识符。

---

### 🧩 关键依赖

| 方法/字段 | 来源 | 说明 |
|----------|------|------|
| `tbOrgUnitMapper.selectTbOrgUnitInfoByOrgId(orgId)` | Mapper | 根据组织 ID 查询组织信息 |
| `tbOrgUnitMapper.selectLeaderPosDeptByUserCode(empCode)` | Mapper | 根据员工工号查询其主管组织列表 |
| `e.getProperties()` / `e.setProperties("1")` | `TbOrgUnit` 对象 | 获取或设置组织的属性字段 |

---

### ✅ 返回值

- 返回一个 `List<TbOrgUnit>` 类型的结果，每个元素代表一个组织信息；
- 包含字段如：
  - `level`：组织层级；
  - [properties](file://E:\project\IdeaProjects\hq\HCMSELF-CONTROLLER_1.1\hq-pro\target\classes\META-INF\app.properties)：组织属性（已保证不为空）；
  - 其他组织相关字段。

---

### 📌 最终用途

此方法被 `selectTbOrgUnitByOrgAndUser` 调用，用于当组织 ID 为空时，默认取用户主职组织信息。尤其对于 CEO 这种核心角色，保证其组织信息的稳定性与准确性，避免因为兼岗或数据配置异常导致错误。

---

### 🔒 特别注意

- `"6042d4ad0d654ddf819926f023b4d968"` 是一个固定组织 ID，不应轻易修改；
- 若将来 CEO 所属组织变更，应更新此处硬编码的值；
- [properties](file://E:\project\IdeaProjects\hq\HCMSELF-CONTROLLER_1.1\hq-pro\target\classes\META-INF\app.properties) 字段的默认值 `"1"` 应与业务逻辑保持一致（如代表“非制造类组织”）。

---

### 📎 示例返回值（简化）

```json
[
  {
    "orgId": "6042d4ad0d654ddf819926f023b4d968",
    "level": "L1",
    "properties": "1"
  }
]
```


---

### ✅ 总结一句话：

> 当调用者是 CEO 时，系统强制返回指定组织信息（“华勤技术股份有限公司”），否则按普通员工查询其主管组织，并统一处理 [properties](file://E:\project\IdeaProjects\hq\HCMSELF-CONTROLLER_1.1\hq-pro\target\classes\META-INF\app.properties) 空值，以保障后续业务使用的一致性与稳定性。





# xml的查询逻辑

这段 SQL 是用于查询某个员工（通过 `empCode`）在其主管岗位下的所有组织信息，并返回一个 `List<TbOrgUnit>`。这个 SQL 对应的是 Java 方法 `selectLeaderPosDeptByUserCode(empCode, postName)`，其核心逻辑是：

---

### 📌 **SQL 功能概括**

**目的：**
> 根据员工工号 `empCode` 查询该员工在“主管岗位”下所管理的组织信息列表。

---

## 🔍 **SQL 结构详解**

```sql
SELECT DEPT.C_HID, DEPT.C_CODE, DEPT.C_NAME, DEPT.c_LEVEL, NVL(UPR.C_PROPERTIES,'1') as C_PROPERTIES
FROM
TB_ORG_POSITION POS,
TB_STA_EMP_ORG EMPORG,
TB_ORG_ORGUNIT DEPT
LEFT JOIN ( ... ) UPR ON DEPT.C_HID = UPR.C_HID
WHERE ...
ORDER BY EMPORG.C_DEPT_TYPE,DEPT.C_LEVEL
```


### ✅ 三张主表说明：

| 表名 | 作用 |
|------|------|
| `TB_ORG_POSITION` (`POS`) | 存储岗位信息 |
| `TB_STA_EMP_ORG` (`EMPORG`) | 存储员工与岗位、组织的关系 |
| `TB_ORG_ORGUNIT` (`DEPT`) | 存储组织单元信息 |

---

### ✅ LEFT JOIN 子查询（`UPR`）：

```sql
(SELECT U.C_HID, '0' AS C_PROPERTIES FROM TB_ORG_ORGUNIT U WHERE U.C_HID IN
(SELECT R1.C_ORG_HID  FROM (SELECT R.C_ORG_HID, R.C_SUPERIOR_HID  FROM TB_ORG_UNITRELATION R
WHERE R.C_DIM_HID = '65ca64ab44274d789f8e958abbddc406'
AND R.C_BEGIN_DATE <= TRUNC(CURRENT_DATE)
AND R.C_END_DATE >= TRUNC(CURRENT_DATE)
AND R.C_STATUS = '1') R1
START WITH R1.C_ORG_HID IN (
    SELECT U.C_HID FROM TB_ORG_ORGUNIT U
    WHERE U.C_PROPERTIES = '0'
    AND U.C_BEGIN_DATE <= TRUNC(SYSDATE)
    AND U.C_END_DATE >= TRUNC(SYSDATE)
)
CONNECT BY PRIOR R1.C_SUPERIOR_HID = R1.C_ORG_HID)
AND U.C_STATUS = '1'
AND U.C_BEGIN_DATE <= TRUNC(SYSDATE)
AND U.C_END_DATE >= TRUNC(SYSDATE))
```


#### 🧱 作用：
- 这个子查询是一个 **递归查询（Hierarchical Query）**，用来查找所有具有某种特定属性（`C_PROPERTIES = '0'`）的组织；
- 然后通过组织关系表 `TB_ORG_UNITRELATION` 向上追溯这些组织的所有上级组织；
- 最终将这些组织的 `C_PROPERTIES` 设置为 `'0'`，表示“制造类组织”。

#### ⚠️ 注意：
- 如果某个组织没有匹配到 `UPR` 中的记录，则使用默认值 `'1'`（非制造类组织）。

---

### ✅ 主查询字段映射

| 字段名 | 来源 | 说明 |
|--------|------|------|
| `DEPT.C_HID` | `TB_ORG_ORGUNIT` | 组织唯一标识符 |
| `DEPT.C_CODE` | `TB_ORG_ORGUNIT` | 组织编码 |
| `DEPT.C_NAME` | `TB_ORG_ORGUNIT` | 组织名称 |
| `DEPT.C_LEVEL` | `TB_ORG_ORGUNIT` | 组织层级 |
| `NVL(UPR.C_PROPERTIES,'1')` | 左连接结果或默认值 | 组织属性，若为空则设为 `'1'`（非制造类） |

---

## 🎯 **关键过滤条件分析**

```sql
WHERE POS.C_OU_HID = DEPT.C_HID
AND EMPORG.C_POSITION_HID = POS.C_HID
AND DEPT.C_BEGIN_DATE <= TRUNC(CURRENT_DATE)
AND DEPT.C_END_DATE >= TRUNC(CURRENT_DATE)
AND POS.C_BEGIN_DATE <= TRUNC(CURRENT_DATE)
AND POS.C_END_DATE >= TRUNC(CURRENT_DATE)
AND EMPORG.C_BEGIN_DATE <= TRUNC(CURRENT_DATE)
AND EMPORG.C_END_DATE > TRUNC(CURRENT_DATE)
AND DEPT.C_STATUS = '1'
AND POS.C_STATUS = '1'
AND POS.C_LEADER_POS = '1'
AND EMPORG.C_DEPT_TYPE in ('1','2')
AND EMPORG.C_EMPLOYEE_ID IN (SELECT C_OID FROM TB_STA_EMP WHERE C_CODE = #{empCode})
```


| 条件 | 含义 |
|------|------|
| `POS.C_OU_HID = DEPT.C_HID` | 岗位所属组织 = 当前组织 |
| `EMPORG.C_POSITION_HID = POS.C_HID` | 员工所在岗位 = 当前岗位 |
| 时间有效性判断 | 确保当前日期在有效期内 |
| `DEPT.C_STATUS = '1'` / `POS.C_STATUS = '1'` | 组织和岗位状态有效 |
| `POS.C_LEADER_POS = '1'` | 只查“主管岗位” |
| `EMPORG.C_DEPT_TYPE in ('1','2')` | 仅限主职或兼岗 |
| `EMPORG.C_EMPLOYEE_ID IN (...)` | 员工编号匹配传入的 `empCode` |

---

## 🧭 **排序逻辑**

```sql
ORDER BY EMPORG.C_DEPT_TYPE, DEPT.C_LEVEL
```


- 先按部门类型排序（主职优先）；
- 再按组织层级排序（高层级排前面）；

---

## 🧩 **关联结构图**

```plaintext
TB_STA_EMP → [C_OID] 
           ↓
TB_STA_EMP_ORG → [C_POSITION_HID] → TB_ORG_POSITION → [C_OU_HID] → TB_ORG_ORGUNIT
           ↑                          ↑
          C_EMPLOYEE_ID               C_HID ← LEFT JOIN → UPR (C_PROPERTIES)
```


---

## 💡 **业务意义总结**

### 📌 查询目标：
获取某位员工在“主管岗位”下所管辖的组织信息列表。

### 🧾 返回字段包括：
- 组织 ID、编码、名称、层级；
- 组织属性（制造类/非制造类，默认为 `'1'`）；

### 📋 查询条件：
- 必须是有效的主管岗位；
- 员工必须在职；
- 岗位、组织、员工关系有效；
- 组织属性根据是否为制造类进行处理（空值补 `'1'`）；

---

## 🧮 示例数据输出（简化）

```json
[
  {
    "hid": "org_001",
    "code": "D001",
    "name": "研发部",
    "level": "L3",
    "properties": "1"
  },
  {
    "hid": "org_002",
    "code": "D002",
    "name": "测试部",
    "level": "L2",
    "properties": "0"
  }
]
```


---

## 📌 特别注意点

### 🔁 递归查询部分：
```sql
START WITH R1.C_ORG_HID IN (SELECT U.C_HID FROM TB_ORG_ORGUNIT U WHERE U.C_PROPERTIES = '0' ...)
CONNECT BY PRIOR R1.C_SUPERIOR_HID = R1.C_ORG_HID
```

- 使用 Oracle 的 `CONNECT BY` 实现了组织树的递归查询；
- 起始节点是“制造类组织”，然后向上追溯其所有上级组织；
- 最终这些组织的 `C_PROPERTIES` 被设置为 `'0'`。

### ⚠️ 属性默认值：
```sql
NVL(UPR.C_PROPERTIES,'1')
```

- 若未找到制造类组织的属性，则默认为 `'1'`（非制造类）；
- 防止后续业务因空值出错。

---

## 📝 总结一句话：

> 该 SQL 通过员工工号 `empCode` 查询其在“主管岗位”下所对应的组织信息，并通过递归方式确定每个组织是否为“制造类组织”，若不是或为空则统一标记为“非制造类组织（1）”。最终返回包含组织 ID、编码、名称、层级、属性的列表，供系统后续权限、流程等业务使用。

---

### ✅ 适用于以下场景：
- 获取用户登录时的默认组织信息；
- 控制不同组织层级的数据权限；
- 判断组织是否属于制造类以决定审批流程；
- CEO 等特殊岗位的组织固定配置；

---

如需进一步解释具体某一部分（比如递归结构、时间范围、JOIN 逻辑），可以继续提问。




# 结果排序


返回的组织列表是按照以下排序逻辑进行排序的：

```sql
ORDER BY EMPORG.C_DEPT_TYPE, DEPT.C_LEVEL
```


---

### ✅ **排序规则详解**

#### 1. `EMPORG.C_DEPT_TYPE`（部门类型）**升序**
- 取值范围：`'1'` 表示主职，`'2'` 表示兼岗。
- 排序含义：主职（`'1'`）排在前面，兼岗（`'2'`）排在后面。

#### 2. `DEPT.C_LEVEL`（组织层级）**升序**
- 组织层级越低（例如：班组级、小组级），数值越小；
- 组织层级越高（例如：公司级、中心级），数值越大。
- 所以按升序排列时，**先返回的是最底层的组织**，然后是上级组织。

---

### 📌 **结论：**

> 是的，该查询返回的组织列表中：
> - **组织 ID 是按从最低层级到最高层级升序排列的**；
> - 同一员工的多个组织中，**主职优先**；
> - 主职和兼岗内部各自按组织层级由低到高排列。

---

### 🔍 示例数据说明

假设组织结构如下：

| 层级 (`C_LEVEL`) | 组织名称 | 类型 |
|------------------|----------|------|
| 5                | 班组A    | 主职 |
| 4                | 科室A    | 主职 |
| 3                | 部门A    | 主职 |
| 2                | 中心A    | 主职 |
| 4                | 科室B    | 兼岗 |

那么 SQL 查询结果会是：

```plaintext
[班组A (L5), 科室A (L4), 部门A (L3), 中心A (L2), 科室B (L4)]
```


即：
- 主职排前面；
- 主职内部按层级从小到大（从最底层组织开始）；
- 兼岗排后面；
- 兼岗内部也按层级从小到大排序。

---

### 🧠 补充说明

这种排序方式适合以下业务场景：
- 用户登录时需要默认选择一个组织作为当前工作组织，优先选择主职中最底层组织；
- 展示组织树时，便于递归构建从叶子节点到根节点的路径；
- 在 UI 上展示组织结构时，保证顺序合理。

---

如需按组织层级 **降序**（即从高层级到低层级）排列，可将排序语句修改为：

```sql
ORDER BY EMPORG.C_DEPT_TYPE, DEPT.C_LEVEL DESC
```











# end