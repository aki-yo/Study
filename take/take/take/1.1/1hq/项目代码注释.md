# begin(侧重项目代码的理解，业务代码理解)

```java
@RestController  
@RequestMapping("/manager/absence")  
@RequiredArgsConstructor  //结合final进行构造（推荐
public class AbsencePeopleController extends BaseController {  
  
    private final AbsencePeopleServiceImpl absencePeopleService;  
  
    private final TeamBoardAttendanceMapper teamBoardAttendanceMapper;  
    private final TokenService tokenService;  
    private final ManagerCommonService managerCommonService;  
    /**  
     * 当天缺勤人数明细  
     */  
    @Log(title = "当天缺勤人数明细（班组长）", businessType = BusinessType.OTHER)  
    @PostMapping("/abesenceDetail")  
    public TableDataInfo abesenceDetail(@RequestBody AbsenceRequestInfo requestInfo) {
    //getloginuser：getrequeset getheader->token->change token->parse token->claims->uuid->add pre->userkey->and redis->loginuser  
        LoginUser loginUser = tokenService.getLoginUser(ServletUtils.getRequest());  
        SysUser user = loginUser.getUser();  
        //校验组织合法性以及是否为空,为空则自动获取主职对应组织，如果主职返回同样为空，则提示报错  
        String orgHid = managerCommonService.checkUnitInfoByUserCode(user,requestInfo.getOrgHidString());  
        requestInfo.setOrgHidString(orgHid);  //baseentity
        DynamicDataSourceContextHolder.setDataSourceType("SLAVE");  
        List<String> excludeIds = teamBoardAttendanceMapper.excludeId();  
        List<List<String>> excludeIdList = CollectSelfUtil.handleOverThousand(excludeIds, 1000);  
        PageInfo<AbsenceVo> pageInfo = absencePeopleService.abesenceDetail(requestInfo, excludeIdList);  
        return getDataTable(pageInfo.getList(), (int) pageInfo.getTotal());  
    }
```
controller:
获取user
获取主组织
设置主组织
设置动态数据源
获取排除的人
分割排除人列表
查询得数据
返回数据

imp:
startpage
mapper查询
return pageinfo
```java
PageHelper.startPage(requestInfo.getPageNum(), requestInfo.getPageSize());  
List<AbsenceVo> list = absencePeopleMapper.abesenceDetail(requestInfo, conditionSql, excludeIdList);  
return new PageInfo<>(list);
```
```java
Page<TbTmgConattendays> startPage = PageHelper.startPage(requestInfo.getPageNum(), requestInfo.getPageSize());  
List<TbTmgConattendays> list = tbTmgConattendaysMapper.queryContinueAttendanceDetails(requestInfo);  
return PageUtil.getPageInfo(requestInfo.getPageNum(), requestInfo.getPageSize(), list, startPage.getTotal());
```

两种分页方式，后者是直接返回page了，第一个返回前端，有getdatatable封装了一下



获取星期首尾
```
LocalDate[] weekDates = WeekDateCalculator.getWeekStartAndEnd(date);
```

```java
//根据用户信息和组织ID查询组织相关信息 层级和属性  
return tbOrgUnitService.selectTbOrgUnitByOrgAndUser(orgHid, user.getUserName());
```

```
List<BiCoreTalentResign> list = biCoreTalentResignMapper.coreTalentResignVpDirector(getPastYears(PAST_YEARS), tbOrgUnit.getCode());
```
这么暴力？直接返回年列表进行查询？


## excel导出
```
ExcelUtil<CurrentEmpCompensationVo> util = new ExcelUtil<CurrentEmpCompensationVo>(CurrentEmpCompensationVo.class);  
return util.exportExcel(currentEmpCompensationService.selectExportCompensation(currentEmpCompensationRequest,user.getUserName()), "员工当前薪酬导出");
```

![](assets/Pasted%20image%2020250707162327.png)
简单方式获得user




```
SysUser user = getTokenSysUser();  
managerTxcParamVo.setManager(AES256Util.encrypt(user.getUserName()));  
CeoManageParamDTO<ManagerTxcParamVo> paramDTO = new CeoManageParamDTO();  
paramDTO.setValue(managerTxcParamVo);  
return manageSalaryManagerService.exportTxcDetail(paramDTO);
```

获取当前登录用户的用户名；
对用户名进行加密处理；
将加密后的用户名封装到一个 DTO 对象中；
调用服务层方法，传递封装好的参数，以导出经理的详细薪资信息


```
sysConfiguration.setCreateTime(DateUtils.getNowDate());
```
时间工具类




## 递归查询
### 步骤2.1：定位根节点

根据`START WITH R1.C_ORG_HID = '007922a93a9846a996e712b9ab4fce72'`定位到初始节点。

### 步骤2.2：递归查找父节点

按照`CONNECT BY PRIOR R1.C_ORG_HID = R1.C_SUPERIOR_HID`定义的规则向上递归：

1. **第一轮**：从指定组织ID出发，找到其直接上级组织（即满足`C_ORG_HID = 当前组织的C_SUPERIOR_HID`的记录）










# 核心人才离职率

[BiCoreTalentResignServiceImpl.java](file://E:\project\IdeaProjects\hq_study\HCMSELF-CONTROLLER_1.1\hq-pro\src\main\java\com\o\project\manager\service\impl\BiCoreTalentResignServiceImpl.java) 是一个 Java 类文件，通常用于实现某个业务逻辑接口的具体方法。从你提供的代码片段来看，这个类属于 `com.o.project.manager.service.impl` 包，并且很可能与核心人才离职（resign）相关的数据分析或报表生成有关。

### 代码片段分析

```java
List<Map<String, Object>> lineData = coreTalentVpDirectorToLineData(list);
resultMap.put("bottomTitle", getCoreTalentVpDirectorBottomTitle());
resultMap.put("month", getAxisTitle(getAxisOneYear()));
resultMap.put("lineData", lineData);
```


这段代码的作用可以总结如下：

1. **数据转换**：
   - `coreTalentVpDirectorToLineData(list)`：将输入的 `list` 数据结构转换为适合前端展示的 `List<Map<String, Object>>` 格式，通常用于图表中的折线图或柱状图数据。
   
2. **设置底部标题**：
   - `getCoreTalentVpDirectorBottomTitle()`：获取图表的底部标题，可能是一个字符串，表示 X 轴或者整个图表的标题。

3. **设置时间轴标题**：
   - `getAxisTitle(getAxisOneYear())`：获取时间轴的标题，可能是“月份”、“季度”等，具体取决于 `getAxisOneYear()` 的实现。

4. **组装结果**：
   - 将处理后的数据和标题信息放入 `resultMap` 中，最终返回给调用者，通常是前端页面或其他服务层组件，用于渲染图表或展示数据。

### 总结

- **主要功能**：该类负责将核心人才（尤其是 VP 和 Director 级别）的离职数据进行处理并转换为适合前端展示的格式。
- **典型用途**：用于生成人才流失趋势图、离职率统计图等人力资源相关的数据可视化报表。

如果需要更详细的解释或扩展，请提供更多的上下文或具体的业务需求。

# groupingby

//2、获取华勤下全部编制 各组织(含下级) 对应的员工类型的编制数，如组织没有编制数默认为0  
Map<String, List<ManagePlaitCntInfo\>> deptHidPlaitCntMap = tbOrgManagePlaitReportMapper.manageDeptPlaitReportCnt().stream()/*组织id 在职，非制造O类*/  
        .filter(s -> StrUtil.isNotBlank(s.getDeptHid()))  
        .collect(Collectors.groupingBy(ManagePlaitCntInfo::getDeptHid));
        


# pmdp


根据我的分析，前端项目中将省份编号转换为中文名称的过程如下：

1. 在`src\views\modules\manager\index.vue`中，通过调用后端接口获取省份字典数据：
   ```javascript
   getDicts('pmdp:provice:001').then(response => {
       this.proviceList = response.data;
   });
   ```

   这个请求会从后端获取所有省份的编号和对应名称的字典数据。

2. 在表格中显示省份信息时，使用了`:formatter="sourceProviceFormat"`：
   ```html
   <el-table-column
       :label="$t('manager.provice')"
       prop="provice"
       header-align="center"
       align="center"
       :formatter="sourceProviceFormat"/>
   ```


3. `sourceProviceFormat`函数定义如下：
   ```javascript
   sourceProviceFormat(row, column) {
       return selectDictLabel(this.proviceList, row.provice);
   }
   ```


4. [selectDictLabel](file://E:\project\IdeaProjects\hq\PMDP-FRONTEND_1.1\src\utils\hq.js#L1-L10)工具函数（在`src/utils/hq.js`中定义）会遍历字典列表，找到与传入值匹配的项并返回其标签：
   ```javascript
   export function selectDictLabel(datas, value) {
       var actions = [];
       Object.keys(datas).map((key) => {
           if (datas[key].dictValue == ('' + value)) {
               actions.push(datas[key].dictLabel);
               return false;
           }
       })
       return actions.join('');
   }
   ```


总结：前端通过调用[getDicts('pmdp:provice:001')](file://E:\project\IdeaProjects\hq\PMDP-FRONTEND_1.1\src\api\api-sys.js#L4-L9)获取省份字典数据保存在`proviceList`中，当需要显示省份信息时，通过`sourceProviceFormat`函数结合[selectDictLabel](file://E:\project\IdeaProjects\hq\PMDP-FRONTEND_1.1\src\utils\hq.js#L1-L10)工具函数，在`proviceList`中查找编号对应的中文名称并显示。




# 函数式接口与执行过程分析
```java

// 调用函数
queryDataFromHCMByConditionSqlIntoOrgManagement(DAILY_MANAGEMENT_TASK, StaffEnum.TOBECONFIRMED, configuration -> dailyManagementMapper.queryToBeConfirmed(configuration.getConditionSql(), configuration.getTwoClassify()));

// 函数定义
protected void queryDataFromHCMByConditionSqlIntoOrgManagement(int taskType, StaffEnum nameEnum, QueryCondition condition) {
// 执行sql查询
orgAmountList = condition.executeQuery(configuration);
}

// 函数式接口
@FunctionalInterface
interface QueryCondition {
List<ConfigurationTask.OrganizationAmount> executeQuery(SysConfiguration configuration);
}



```

根据这三个之间的使用关系，告诉我这个函数式接口相关知识的详细知识，以及执行过程


### 执行流程

1. **方法调用**：调用 `queryDataFromHCMByConditionSqlIntoOrgManagement` 方法，传入三个参数
2. **Lambda表达式**：第三个参数是一个Lambda表达式，它实现了 `QueryCondition` 接口
3. **方法执行**：在 `queryDataFromHCMByConditionSqlIntoOrgManagement` 方法内部，调用 `condition.executeQuery(configuration)`
4. **Lambda执行**：实际执行的是传入的Lambda表达式，即调用 `dailyManagementMapper.queryToBeConfirmed` 方法
5. **结果返回**：查询结果以 `List<ConfigurationTask.OrganizationAmount>` 形式返回

这个地方传递只是一种执行逻辑



# 链式编程 直接设置类的字段

```java
// 获取组织id和对应数量  
classifyArrayList.addAll(orgAmountList.stream()  
        .filter(org -> StrUtil.isNotBlank(org.getOrganizationId()) && org.getAmount() != 0)  
        .map(org -> new TwoClassifySqlValue()  
                .setConfigId(configuration.getId())  
                .setConditionSql(configuration.getConditionSql())  
                .setOrganizationId(org.getOrganizationId())  
                .setAmount(org.getAmount())  
                .setConfigType(name)  
                .setOverTime(org.getOverTime())  
                .setType(taskType)
            )  
        .collect(Collectors.toList()));
```

```java
Map<String, SysUser> selfUserMap = sysUsers.stream().collect(Collectors.toMap(SysUser::getUserName, t -> t, (t1, t2) -> t2));
```


```java
public void commonCodeLocale(List<String> codes, String locale /*lang code*/) {  
    /*获取某个语言下的 所有常数代码 数据结构  加到redis*/  
    /*分批 发送请求， 得到大量list 根据 常数代码 进行分组排序 进行 构造树型结构（这里面就是 -1父节点 为一层 途中添加 child )*/    CollUtil.split(codes, 20).forEach(subCodesList -> {  
        CommonCodeEsbReqVo esbReqVo =  new CommonCodeEsbReqVo();  
        esbReqVo.setTypeCodeList(subCodesList);  
        esbReqVo.setLang(LanguageHcmEnum.getHcmLanguage(locale).getHcmCode());  
        String result = esbServiceUtil.post("HCM", "REST_HCM_GETCOMMONCODES", esbReqVo);  
        JSONObject map = JSONObject.parseObject(result);  
        if (null != map && map.containsKey("EsbResData")) {  
            JSONArray array = map.getJSONArray("EsbResData");  
            if (!CollectionUtils.isEmpty(array)) {  
                List<CommonCodeEsbRespVo> respVoList = array.toJavaList(CommonCodeEsbRespVo.class);  
                //将结果分组并排序  
                Map<String,List<CommonCodeEsbRespVo>> groupedMap = respVoList.stream()  
                        /*收集*/  
                        .collect(  
                                /*分组*/  
                                Collectors.groupingBy(  
                                        /*根据typecode进行分组*/  
                                        CommonCodeEsbRespVo::getTypeCode,  
                                        /*分组之后的每个组的数据*/  
                                        Collectors.collectingAndThen(  
                                                /*每个组的数据聚合为一个List*/  
                                                Collectors.toList(),  
                                                /*这个聚合后的list叫做sublist 注意这个只是一组 然后进行排序*/  
                                                subList->subList.stream().sorted(  
                                                        Comparator.comparing(  
                                                                CommonCodeEsbRespVo::getSort  
                                                        )  
                                                ).collect(  
                                                        /*排序完成后 接着收集为一个list */  
                                                        Collectors.toList()  
                                                )  
                                        )  
                                )  
                        );  
                for(String m : subCodesList){/*这个m就是 常数代码的 code （总名字）*/  
                    List<CommonCodeEsbRespVo> codesResList = groupedMap.get(m);  
                    if(CollUtil.isNotEmpty(codesResList)){  
                        //组装树形结构  
                        List list = buildTree(codesResList,"-1");  
                        //存入redis  vimobile  
                        String redisKey = locale+"self_"+m;  
                        log.info(locale+"常熟代码:" + redisKey+"组装返回树形结构："+ JSON.toJSONString(list));  
                        if (redisCache.hasKey(redisKey)) {  
                            redisCache.deleteObject(redisKey);  
                        }  
                        redisCache.setCacheList(redisKey, list);  
                    }  
                }  
            }  
        }  
    });  
}
```


```java
List<SysUserUpm> sysUserUpms = sysUserUpmMapper.selectAll();
        List<UserUpmVO> userUpmVOS = new ArrayList<>();
        Map<String, List<SysUserUpm>> collect = sysUserUpms.stream().collect(Collectors.groupingBy(SysUserUpm::getUserCode));
        collect.forEach((k, v) -> {
            UserUpmVO userUpmVO = new UserUpmVO();
            userUpmVO.setUserCode(k);
            v.forEach(ele->{
                if(ele.getType() == 1) {
                    userUpmVO.setRoleId(userUpmVO.getRoleId() + "," + ele.getRoleId());
                }else if(ele.getType() == 2) {
                    userUpmVO.setOrgCode(userUpmVO.getOrgCode() + "," + ele.getOrgCode());
                }
            });
            userUpmVOS.add(userUpmVO);
        });

这个能合并成一个链式编程吗
```

当然可以！可以使用 `Collectors.collectingAndThen` 和 `Collectors.toMap` 来实现链式编程。以下是几种优化方案：

## 方案1：使用 collectingAndThen + toMap（推荐）

```java
List<UserUpmVO> userUpmVOS = sysUserUpms.stream()
    .collect(Collectors.collectingAndThen(
        Collectors.groupingBy(SysUserUpm::getUserCode),
        // 经过分组然后得到一个map 然后对map进行以下操作
        map -> map.entrySet().stream()
            .map(entry -> {
                UserUpmVO vo = new UserUpmVO();
                vo.setUserCode(entry.getKey());
                
                String roles = entry.getValue().stream()
                    .filter(ele -> ele.getType() == 1)
                    .map(ele -> ele.getRoleId().toString())
                    .collect(Collectors.joining(","));
                vo.setRoleId(roles.isEmpty() ? "" : roles);
                
                String orgs = entry.getValue().stream()
                    .filter(ele -> ele.getType() == 2)
                    .map(SysUserUpm::getOrgCode)
                    .collect(Collectors.joining(","));
                vo.setOrgCode(orgs.isEmpty() ? "" : orgs);
                
                return vo;
            })
            .collect(Collectors.toList())
    ));
```

## 方案2：使用 toMap 自定义合并（更简洁）

```java
List<UserUpmVO> userUpmVOS = new ArrayList<>(
    sysUserUpms.stream()
        .collect(Collectors.toMap(
            SysUserUpm::getUserCode,
            ele -> {
                UserUpmVO vo = new UserUpmVO();
                vo.setUserCode(ele.getUserCode());
                if (ele.getType() == 1) {
                    vo.setRoleId(ele.getRoleId().toString());
                } else if (ele.getType() == 2) {
                    vo.setOrgCode(ele.getOrgCode());
                }
                return vo;
            },
            (vo1, vo2) -> {
                if (vo1.getRoleId() != null && vo2.getRoleId() != null) {
                    vo1.setRoleId(vo1.getRoleId() + "," + vo2.getRoleId());
                } else if (vo2.getRoleId() != null) {
                    vo1.setRoleId(vo2.getRoleId());
                }
                
                if (vo1.getOrgCode() != null && vo2.getOrgCode() != null) {
                    vo1.setOrgCode(vo1.getOrgCode() + "," + vo2.getOrgCode());
                } else if (vo2.getOrgCode() != null) {
                    vo1.setOrgCode(vo2.getOrgCode());
                }
                return vo1;
            }
        ))
        .values()
);
```

## 方案3：使用 reduce 操作（函数式风格）

```java
List<UserUpmVO> userUpmVOS = sysUserUpms.stream()
    .collect(Collectors.groupingBy(SysUserUpm::getUserCode))
    .entrySet().stream()
    .map(entry -> entry.getValue().stream()
        .reduce(new UserUpmVO(), 
            (vo, ele) -> {
                vo.setUserCode(entry.getKey());
                if (ele.getType() == 1) {
                    String current = vo.getRoleId() != null ? vo.getRoleId() : "";
                    vo.setRoleId(current + (current.isEmpty() ? "" : ",") + ele.getRoleId());
                } else if (ele.getType() == 2) {
                    String current = vo.getOrgCode() != null ? vo.getOrgCode() : "";
                    vo.setOrgCode(current + (current.isEmpty() ? "" : ",") + ele.getOrgCode());
                }
                return vo;
            },
            (vo1, vo2) -> vo1 // 并行流时使用，单线程可忽略
        ))
    .collect(Collectors.toList());
```

## 方案4：最简洁的版本（使用 partitioningBy）

```java
List<UserUpmVO> userUpmVOS = sysUserUpms.stream()
    .collect(Collectors.groupingBy(SysUserUpm::getUserCode))
    .entrySet().stream()
    .map(entry -> {
        Map<Boolean, List<SysUserUpm>> partitioned = entry.getValue().stream()
            .collect(Collectors.partitioningBy(ele -> ele.getType() == 1));
        
        UserUpmVO vo = new UserUpmVO();
        vo.setUserCode(entry.getKey());
        vo.setRoleId(partitioned.get(true).stream()
            .map(ele -> ele.getRoleId().toString())
            .collect(Collectors.joining(",")));
        vo.setOrgCode(partitioned.get(false).stream()
            .map(SysUserUpm::getOrgCode)
            .collect(Collectors.joining(",")));
        return vo;
    })
    .collect(Collectors.toList());
```

## 推荐使用方案1，因为：

1. **代码清晰**：逻辑分层明确，易于理解
2. **性能良好**：使用 filtering 和 joining 操作
3. **空值处理**：避免了 null 拼接的问题
4. **可维护性**：每个步骤都很清晰

所有方案都实现了完整的链式编程，避免了显式的 forEach 循环。

## 1
```
  
    List<SysRoleLimit> distinctClass = sysRoleLimits.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(o -> o.getOrgCode() + ";" + o.getRoleLimit() + ";" + o.getEmpCode()))), ArrayList::new));
```



## 1

```
return userUpmVOS.stream().collect(Collectors.collectingAndThen(  
        Collectors.groupingBy(UserUpmVO::getUserCode),  
        map1 -> map1.entrySet().stream().map(  
                entry1 -> {  
                    String rolesName = entry1.getValue().stream()  
                            .filter(ele1 -> "1".equals(ele1.getType())).map(UserUpmVO::getRoleName).collect(Collectors.joining(","));  
                    String orgsName = entry1.getValue().stream().filter(ele1 -> "2".equals(ele1.getType())).map(UserUpmVO::getOrgName).collect(Collectors.joining(","));  
                    String rolesCode = entry1.getValue().stream()  
                            .filter(ele1 -> "1".equals(ele1.getType())).map(UserUpmVO::getRoleId).collect(Collectors.joining(","));  
                    String orgsCode = entry1.getValue().stream().filter(ele1 -> "2".equals(ele1.getType())).map(UserUpmVO::getOrgCode).collect(Collectors.joining(","));  
                    UserUpmVO vo1 = new UserUpmVO();  
                    vo1.setId(entry1.getValue().get(0).getId());  
                    vo1.setUserCode(entry1.getKey());  
                    vo1.setUserName(entry1.getValue().get(0).getUserName());  
                    vo1.setOrgName(orgsName);  
                    vo1.setRoleName(rolesName);  
                    vo1.setRoleId(rolesCode);  
                    vo1.setOrgCode(orgsCode);  
                    return vo1;  
                }  
        ).collect(Collectors.toList())  
));
```













# 存储函数
```
CREATE FUNCTION "GETCODEVALUE" (
    CODE     IN VARCHAR2,    -- 输入参数：代码（如"GENDER"中的具体编码"M"或"F"）
    CODETYPE IN VARCHAR2     -- 输入参数：代码类型（如"GENDER"表示性别分类）
)
RETURN VARCHAR2              -- 返回值类型：字符串（最大长度1024）
IS
    RESULT_ VARCHAR2(1024);  -- 声明局部变量，用于存储查询结果
BEGIN
    -- 从表 TP_V_CODE_RESOURCE_CN 中查询代码值
    SELECT RC.C_CODE_VALUE
    INTO RESULT_
    FROM TP_V_CODE_RESOURCE_CN RC
    WHERE RC.C_CODE = CODE          -- 匹配代码
      AND RC.C_TYPE_CODE = CODETYPE; -- 匹配代码类型
    
    RETURN(RESULT_);  -- 返回查询到的代码值
END GETCODEVALUE;
/
```


# 能直接xml查询结果映射为map

![](assets/Pasted%20image%2020250812152042.png)
```
organizationIdAndAmount.put(String.valueOf(map.get("ORGANIZATIONID")), String.valueOf(map.get("AMOUNT")));
```
映射之后好像自动转化成大写欸，



# 数据库函数
```sql
create FUNCTION "GETCODEVALUE" (CODE     IN VARCHAR2,  
                               CODETYPE IN VARCHAR2)  
    RETURN VARCHAR2 IS  
    RESULT_ VARCHAR2(1024);  
BEGIN  
    SELECT RC.C_CODE_VALUE  
    INTO RESULT_  
    FROM TP_V_CODE_RESOURCE_CN RC  
    WHERE RC.C_CODE = CODE  
      AND RC.C_TYPE_CODE = CODETYPE;  
    RETURN(RESULT_);  
END GETCODEVALUE;  
/  
  
/*CREATE FUNCTION "GETCODEVALUE" (  
    CODE     IN VARCHAR2,    -- 输入参数：代码（如"GENDER"中的具体编码"M"或"F"）  
    CODETYPE IN VARCHAR2     -- 输入参数：代码类型（如"GENDER"表示性别分类）  
)  
RETURN VARCHAR2              -- 返回值类型：字符串（最大长度1024）  
IS  
    RESULT_ VARCHAR2(1024);  -- 声明局部变量，用于存储查询结果  
BEGIN  
    -- 从表 TP_V_CODE_RESOURCE_CN 中查询代码值  
    SELECT RC.C_CODE_VALUE    INTO RESULT_    FROM TP_V_CODE_RESOURCE_CN RC    WHERE RC.C_CODE = CODE          -- 匹配代码  
      AND RC.C_TYPE_CODE = CODETYPE; -- 匹配代码类型  
  
    RETURN(RESULT_);  -- 返回查询到的代码值  
END GETCODEVALUE;  
/*/
```


# mybatis

```
public class IpmtAffBusinessService extends ServiceImpl<IpmtAffBusinessMapper, IpmtAffBusiness> {

这个service就可以直接用save方法自动生成主键 mybatis-plus的强大

```



![](assets/Pasted%20image%2020250822145508.png)
有时候会报错是因为你这个文件在应用程序中打开了，没办法被覆盖

![](assets/Pasted%20image%2020250822155050.png)
通过这种方式来使得控制哪个字段用于这个excel文件导出，然后还有tablefield来控制属性和数据库字段之间的映射
不对，这个地方需要是针对那一张表，不能直接映射连表的另外的属性











# end