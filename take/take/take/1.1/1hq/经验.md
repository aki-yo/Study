# begin(侧重学到的，学习笔记)



# 锁
```
// 初始状态：中断标志 = false
Thread.currentThread().isInterrupted(); // 返回 false

// 外部请求中断（比如调用 thread.interrupt()）
thread.interrupt(); 
// 此时中断标志 = true

// 当线程执行到可中断方法（如 sleep()）时：
Thread.sleep(100); 
// 如果此时中断标志=true，则：
//   - sleep() 会立即抛出 InterruptedException
//   - JVM 会自动清除中断标志（重置为 false）

//所以之后还需要  Thread.currentThread().interrupt()  来中断恢复让后续代码知道曾经中断过
```


## esb
```java
package com.huaqin.hcm.client;  
  
import com.huaqin.hcm.config.FeignMultipartConfiguration;  
import com.huaqin.hcm.entity.dto.esb.EsbRequestDTO;  
import com.huaqin.hcm.entity.dto.esb.EsbResponseDTO;  
  
import org.springframework.cloud.openfeign.FeignClient;  
import org.springframework.http.MediaType;  
import org.springframework.web.bind.annotation.RequestBody;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RequestMethod;  
  
import java.util.List;  
  
/**  
 * <p>  
 *  
 * </p>  
 *  
 * @author 101011125  
 * @since 20220214  
 */@FeignClient(value = "EsbClient", url = "${hq.esb.envUrl}", configuration = FeignMultipartConfiguration.class)  
public interface EsbClient {  
    /**  
     * Esb 推送数据  
     *  
     * @param requestList  
     * @param <PUSH_DATA_TYPE>  
     * @return  
     */  
    @RequestMapping(method = RequestMethod.POST, headers = {"Authorization=${hq.esb.auth}"}, produces = MediaType.APPLICATION_JSON_VALUE)  
    <PUSH_DATA_TYPE> EsbResponseDTO commonSendDataList(@RequestBody EsbRequestDTO<List<PUSH_DATA_TYPE>> requestList);  
  
    /**  
     * Esb 推送数据  
     *  
     * @param request  
     * @param <PUSH_DATA_TYPE>  
     * @return  
     */  
    @RequestMapping(method = RequestMethod.POST, headers = {"Authorization=${hq.esb.auth}"}, produces = MediaType.APPLICATION_JSON_VALUE)  
    <PUSH_DATA_TYPE> EsbResponseDTO commonSendData(@RequestBody EsbRequestDTO<PUSH_DATA_TYPE> request);  
}
```
像这样的玩意是用来发送请求的,让目标系统干事情


# xxl-job


[分布式任务调度平台XXL-JOB](https://www.xuxueli.com/xxl-job/#1.5%20%E4%B8%8B%E8%BD%BD)



（这是一种方式）
中心调度运行
自己的项目加注解和配置和依赖xxljob
运行
中心调度添加任务


还有一个是类继承那个IJobHandler
类上加JobHandler注解，或者init里面添加1. `XxlJobExecutor.registJobHandler("demoJobHandler", new DemoJobHandler());`
来注册这个玩意


另外一种方法中的那个bean 类形式，则需要集成那个handler
还是选择注解方式吧

测试可以直接调用函数的



那个源码里面有多个模块，有中心调度以及样例程序
所以应该是可以分开的，因为文档说了把样例程序打包运行

### 3.2 BEAN模式（方法形式）

Bean模式任务，支持基于方法的开发方式，每个任务对应一个方法。

- 优点：
    - 每个任务只需要开发一个方法，并添加”[](https://github.com/XxlJob "@XxlJob")[@XxlJob](https://github.com/XxlJob "@XxlJob")”注解即可，更加方便、快速。
    - 支持自动扫描任务并注入到执行器容器。
- 缺点：略。

> 基于方法开发的任务，底层会生成JobHandler代理，和基于类的方式一样，任务也会以JobHandler的形式存在于执行器任务容器中。

#### 步骤一：执行器项目中，开发Job方法：

1. `1、任务开发：在Spring Bean实例中，开发Job方法；`
2. `2、注解配置：为Job方法添加注解 "@XxlJob(value="自定义jobhandler名称", init = "JobHandler初始化方法", destroy = "JobHandler销毁方法")"，注解value值对应的是调度中心新建任务的JobHandler属性的值。`
3. `3、执行日志：需要通过 "XxlJobHelper.log" 打印执行日志；`
4. `4、任务结果：默认任务结果为 "成功" 状态，不需要主动设置；如有诉求，比如设置任务结果为失败，可以通过 "XxlJobHelper.handleFail/handleSuccess" 自主设置任务结果；`

5. `// 可参考Sample示例执行器中的 "com.xxl.job.executor.service.jobhandler.SampleXxlJob" ，如下：`
6. `@XxlJob("demoJobHandler")`
7. `public void demoJobHandler() throws Exception {`
8.     `XxlJobHelper.log("XXL-JOB, Hello World.");`
9. `}`

#### 步骤二：调度中心，新建调度任务

参考上文“配置属性详细说明”对新建的任务进行参数配置，运行模式选中 “BEAN模式”，JobHandler属性填写任务注解“[@XxlJob](https://github.com/XxlJob "@XxlJob")”中定义的值；

![输入图片说明](https://www.xuxueli.com/doc/static/xxl-job/images/img_ZAsz.png "在这里输入图片标题")




![](assets/Pasted%20image%2020250716202407.png)
闭环了哥们












# 繁




## 繁



## zookeeper

```
client.getData().watched().forPath("/config/db_url", (event) -> {
    System.out.println("配置更新: " + new String(event.getData()));
});
```
大概就是，当这个代码运行之后，
就会有个监听器，
然后当数据变化的时候这里就会触发异步响应
开始执行  System.out.println("配置更新: " + new String(event.getData()));
这个代码就输出结果了
只会监听一次

```
void watchConfig() {
    client.getData().watched().forPath("/config/db_url", (event) -> {
        System.out.println("配置更新: " + new String(event.getData()));
        watchConfig(); // 递归重新注册监听
    });
}

// 首次调用
watchConfig();
```
这个是每次监听后再重新监听



## 数据库
数据库，存储过程，存储函数



![](assets/Pasted%20image%2020251028110733.png)
工具类





环境变量
```
sysdm.cpl
```



配置ssh的算法kexalgothrim什么的玩意

要启动新版idea需要彻底删除20版本




![](assets/Pasted%20image%2020250710202029.png)


`&lt;&gt;` 是 `< >` 的转义写法，在 XML 中用于替代 SQL 中的不等于操作符 `<>`


直接打开hosts文件用记事本，修改需要管理员权限，但是我没有管理员权限，一直失败
今天早上回来看了看ds又随手试了试，又可以了？？就是因为我是管理员身份运行的记事本？？

## 开发技巧


了解新业务之前，可以通过那个sql日志直接看最后的查询sql长什么样子，然后看代码，大概就知道哪些地方有什么作用
![](assets/Pasted%20image%2020251011155213.png)
比如这个地方就可以知道原来代码中还会动态添加 剔除登陆人 的这个sql条件（可能是动态添加的把（

下次记得开发测试的时候，测试结果也记录下来



![](assets/Pasted%20image%2020251011142126.png)
通过这个sql日志方式来了解业务运行的时候到底执行了什么sql然后研究为什么查询的不对






## "代理模式+延迟加载

![](assets/Pasted%20image%2020250930164403.png)

## 静态代码块

```java
package com.jackasher.ageiport.demo;  
  
import java.sql.Connection;  
import java.sql.DriverManager;  
import java.sql.SQLException;  
  
/**  
 * 写demo时测试用的数据,可忽略  
 */  
public class DatabaseUtil {  
      
    private static final String URL = "jdbc:mysql://macbook.local:3306/user-center?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai";  
    private static final String USERNAME = "root";  
    private static final String PASSWORD = "123124312."; // 您的数据库密码  
    static {  
        try {  
            Class.forName("com.mysql.cj.jdbc.Driver");  
        } catch (ClassNotFoundException e) {  
            throw new RuntimeException("MySQL Driver not found", e);  
        }  
    }  
      
    public static Connection getConnection() throws SQLException {  
        return DriverManager.getConnection(URL, USERNAME, PASSWORD);  
    }  
}
```

## 前端调试
debugger
console.log


这段代码和注释表达的意思是：**在Java内存中计算试用期结束日期，而不是通过数据库函数计算**，主要目的是避免数据库索引失效导致的性能问题。以下是详细解析：
### 核心问题

当在SQL查询的`WHERE`条件中使用数据库函数（如Oracle的`ADD_MONTHS`、MySQL的`DATE_ADD`）时：

```sql
-- 反例：会导致索引失效
SELECT * FROM employee 
WHERE ADD_MONTHS(hire_date, 3) = SYSDATE;
```

会导致数据库无法使用`hire_date`字段上的索引，引发全表扫描。









看了这么多真的角色那个数据范围卡控真不错，切面真棒

因为datascope里面是 and开头的，所以前面加了个1= 1 是的语法正确
```sql
SELECT  
    E.*FROM TB_STA_EMP E  
LEFT JOIN TB_STA_EMP_ORG EO ON EO.C_EMPLOYEE_ID = E.C_OID  
WHERE 1=1  
${requestInfo.params.dataScope}  
AND EO.C_EMPLOYEE_STATUS IN ('2')  
AND EO.C_BEGIN_DATE &lt;= TRUNC(SYSDATE)  
AND EO.C_END_DATE > TRUNC(SYSDATE)
```


![](assets/Pasted%20image%2020250908111351.png)
不用一个一个点击菜单，直接在数据库里面复制原有的数据行不就好了
![](assets/Pasted%20image%2020250908111941.png)
直接两边操作，爽




父级组织路线（多个组织用，链接），用find in set函数也就是contain函数来判断这个组织有没有另外一个组织作为父级

```
<if test="roleId != null and roleId != 0">role_id,</if>
```


bak表用来当做临时表，存储失效信息



有些错误不影响效果结果直接return


mybatis-plus 批量插入，service.savebatch
链式编程



如果原来的sql东西很多的话，就直接在java层面上来进行修改过滤数据



有种开发方式是
先在远端新建分支，然后fetch那个分支，然后就在那开发，然后合上去进行测试，然后没问题再合远端分支


当有共同逻辑的时候，可以抽象出来成方法，然后不同情况传入不同的参数
```java
public static final String upload(MultipartFile file) throws IOException
return upload(getDefaultBaseDir(), file, MimeTypeUtils.DEFAULT_ALLOWED_EXTENSION);
public static final String upload(String baseDir, MultipartFile file) throws IOException
return upload(baseDir, file, MimeTypeUtils.DEFAULT_ALLOWED_EXTENSION);

```




### 事务
![](assets/Pasted%20image%2020250728112819.png)
先修改数据库，再进行相关业务操作
上面加上事务注解




### redis
![](assets/Pasted%20image%2020250729153749.png)
redis还可以作为项目间的沟通桥梁






## 配置文件乱码
![](assets/Pasted%20image%2020250722171811.png)
这个地方本来乱码
![](assets/Pasted%20image%2020250722171837.png)
这个地方设置一下就好了





## 调用自己类的构造方法方式
![](assets/Pasted%20image%2020250725110007.png)


## 命令查看实际生效的filter
![](assets/Pasted%20image%2020250725140316.png)
??
还可以这样


## 日期相关
```
return cron.getNextValidTimeAfter(new Date(System.currentTimeMillis()));
```




## 调试技巧

对表达式求值调试方法


条件断点
设置的条件最后**输出的结果应该是一个boolean类型的值**









# mock

![](assets/Pasted%20image%2020250722172736.png)





# springBoot(wuyoujie)



1、前后端分离，页面vue+spring 2、定时任务xxjob调用 3、通过ESB对外提供接口
深入理解学习mvc模式，通常基本都是这些为底层
可以学习学习springboot这些框架是怎么实现的这种模式
MVC模式，springboot内如何应用的
过滤器，拦截器，注解，ioc，aop等等


DispatcherServlet\ServletResponse\ServletRequest\FilterChain 过滤器和拦截器\HttpServletRequest\HttpServletResponse
给我解释这些东西之间的关系，联系，是谁封装了谁，调用了谁，执行过程什么
[请求过程](ds/请求过程.md)



Spring Boot大量使用注解简化配置：

- **请求映射**：`@RequestMapping`, `@GetMapping`, `@PostMapping`等
    
- **参数处理**：`@PathVariable`, `@RequestParam`, `@RequestBody`
    
- **响应处理**：`@ResponseBody`, `@ResponseStatus`
    
- **配置相关**：`@Configuration`, `@Bean`, `@Conditional`

[sprnig boot 注解参数](ds/sprnig%20boot%20注解参数.md)

在前后端分离架构（Vue + Spring Boot）中，**用户访问的网页资源（HTML、CSS、JS、图片等）确实是由 Vue 服务（或前端服务器）提供的，而 Spring Boot 仅负责提供 API 接口返回 JSON/XML 数据**。



# 断言

```java
public static final void assertAllowed(MultipartFile file, String[] allowedExtension)  
        throws FileSizeLimitExceededException, InvalidExtensionException  
{  
    long size = file.getSize();  
    if (DEFAULT_MAX_SIZE != -1 && size > DEFAULT_MAX_SIZE)  
    {  
        throw new FileSizeLimitExceededException(DEFAULT_MAX_SIZE / 1024 / 1024);  
    }  
  
    String fileName = file.getOriginalFilename();  
    String extension = getExtension(file);  
    if (allowedExtension != null && !isAllowedExtension(extension, allowedExtension))  
    {  
        if (allowedExtension == MimeTypeUtils.IMAGE_EXTENSION)  
        {  
            throw new InvalidExtensionException.InvalidImageExtensionException(allowedExtension, extension,  
                    fileName);  
        }  
        else if (allowedExtension == MimeTypeUtils.FLASH_EXTENSION)  
        {  
            throw new InvalidExtensionException.InvalidFlashExtensionException(allowedExtension, extension,  
                    fileName);  
        }  
        else if (allowedExtension == MimeTypeUtils.MEDIA_EXTENSION)  
        {  
            throw new InvalidExtensionException.InvalidMediaExtensionException(allowedExtension, extension,  
                    fileName);  
        }  
        else  
        {  
            throw new InvalidExtensionException(allowedExtension, extension, fileName);  
        }  
    }  
  
}
```

断言函数
什么都不返回，若有错误直接抛出异常
注意 static final void 









# jsonobject

```java
JSONObject requestJson = new JSONObject();  
requestJson.put("EsbReqHeader", esbConfig);  
requestJson.put("EsbReqData", requestDataStr);  
log.info("request params :{}", requestJson.toJSONString());  
//进行请求  
return PostRestfulService(requestJson.toString(), url, authorization);
```




# 过程


# aspect
aspect切面编程(来直接将普遍事务中的公共部分抽离出来)
调用某个目标方法的时候会触发代理对象，然后代理对象调用befor方法，目标方法、after方法
[aspect](ds/aspect.md)
![](assets/Pasted%20image%2020250704141332.png)

```
@Pointcut("@annotation(com.o.framework.aspectj.lang.annotation.DataSource)"  
        + "|| @within(com.o.framework.aspectj.lang.annotation.DataSource)")  
public void dsPointCut()  
{  
  
}
```
这是调用多个方法



# 元注解
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME)是干什么的
[元注解](ds/元注解.md)

如果要扩展 某个类，
就可以直接继承他，然后super,然后重写其中的某个你想扩展或者修改的方法
直接添加个类配合他
![](assets/Pasted%20image%2020250704143716.png)


# 继承与接口

继承就相当于n.
是名词
```
public class LogEvent extends ApplicationEvent {
```
比如这个就是事件的继承，继承过来有一些属性，表明是个事件
我想着为什么不用接口呢
因为接口定义的是工作是v.
是动词
```
public class LogListener implements ApplicationListener<LogEvent> {
```
比如这个就是是监听的作用，实现一下，就有了监听的作用，是监听器了

哦~
```
@Component
public class LogListener {
    private final LogQueue logQueue; // 日志队列(实际可能是Kafka/RabbitMQ等)

    @Async // 异步处理
    @EventListener // 事件监听注解
    public void handleLogEvent(LogEvent event) {
        LogSenderDto logDto = event.getLogDto();
        try {
            // 构造日志实体
            SysLog log = new SysLog();
            log.setModule(logDto.getModule());
            log.setOperation(logDto.getOperation());
            log.setCreateTime(new Date());
            
            // 异步写入日志存储
            logQueue.add(log);
        } catch (Exception e) {
            log.error("日志记录失败: {}", logDto, e);
        }
    }
}
```
原来还有这种定义事件监听器方法
注解方法


# 链式调用
链式调用[链式调用](ds/链式调用.md)

# 多种注入方式
注入方式[RequiredArgsConstructor` + `final](ds/RequiredArgsConstructor`%20+%20`final.md)


# 项目启动自动加载常数代码

```
/**  
 * 系统启动时加载SCM常数代码到redis  
 * * @author XY  
 **/@Component  
public class CacheDataToRun implements CommandLineRunner {
```





# myself


optional类

```java
String value = nullableOpt.orElse("default"); // 空时返回 "default"
String value = nullableOpt.orElseGet(() -> fetchFromDB()); // 空时调用方法
String value = nullableOpt.orElseThrow(() -> new RuntimeException("值不存在"));
```










# end