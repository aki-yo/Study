
# 1

## TokenService
```java
package com.o.framework.security.service;  
  
import java.util.HashMap;  
import java.util.Map;  
import java.util.concurrent.TimeUnit;  
import javax.servlet.http.HttpServletRequest;  
  
import io.jsonwebtoken.*;  
import lombok.extern.slf4j.Slf4j;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.beans.factory.annotation.Value;  
import org.springframework.stereotype.Component;  
import com.o.common.constant.Constants;  
import com.o.common.utils.IdUtils;  
import com.o.common.utils.ServletUtils;  
import com.o.common.utils.StringUtils;  
import com.o.common.utils.ip.AddressUtils;  
import com.o.common.utils.ip.IpUtils;  
import com.o.framework.redis.RedisCache;  
import com.o.framework.security.LoginUser;  
import eu.bitwalker.useragentutils.UserAgent;  
  
/**  
 * token验证处理  
 *   
* @author HQ  
 */@Component  
@Slf4j  
public class TokenService  
{  
    // 令牌自定义标识  
    @Value("${token.header}")  
    private String header;  
  
    // 令牌秘钥  
    @Value("${token.secret}")  
    private String secret;  
  
    // 令牌有效期（默认30分钟）  
    @Value("${token.expireTime}")  
    private int expireTime;  
  
    protected static final long MILLIS_SECOND = 1000;  
  
    protected static final long MILLIS_MINUTE = 60 * MILLIS_SECOND;  
  
    private static final Long MILLIS_MINUTE_TEN = 20 * 60 * 1000L;  
  
    @Autowired  
    private RedisCache redisCache;  
  
    /**  
     * 获取用户身份信息  
     *   
* @return 用户信息  
     */  
    public LoginUser getLoginUser(HttpServletRequest request)  
    {  
        // 获取请求携带的令牌  
        String token = getToken(request);  
        if (StringUtils.isNotEmpty(token))  
        {  
            Claims claims = null;  
            try {  
                claims = parseToken(token);  
            } catch (ExpiredJwtException| MalformedJwtException |SignatureException e) {  
                log.error(e.getMessage());  
                return null;  
            }  
            // 解析对应的权限以及用户信息  
            String uuid = (String) claims.get(Constants.LOGIN_USER_KEY);  
            String userKey = getTokenKey(uuid);  
            LoginUser user = redisCache.getCacheObject(userKey);  
            return user;  
        }  
        return null;  
    }  
  
    /**  
     * 设置用户身份信息  
     */  
    public void setLoginUser(LoginUser loginUser)  
    {  
        if (StringUtils.isNotNull(loginUser) && StringUtils.isNotEmpty(loginUser.getToken()))  
        {  
            refreshToken(loginUser);  
        }  
    }  
  
    /**  
     * 删除用户身份信息  
     */  
    public void delLoginUser(String token)  
    {  
        if (StringUtils.isNotEmpty(token))  
        {  
            String userKey = getTokenKey(token);  
            redisCache.deleteObject(userKey);  
        }  
    }  
  
    /**  
     * 创建令牌  
     *   
* @param loginUser 用户信息  
     * @return 令牌  
     */  
    public String createToken(LoginUser loginUser)  
    {  
        String token = IdUtils.fastUUID();  
        loginUser.setToken(token);  
        setUserAgent(loginUser);  
        refreshToken(loginUser);  
  
        Map<String, Object> claims = new HashMap<>();  
        claims.put(Constants.LOGIN_USER_KEY, token);  
        return createToken(claims);  
    }  
  
    /**  
     * 验证令牌有效期，相差不足20分钟，自动刷新缓存  
     *   
* @param token 令牌  
     * @return 令牌  
     */  
    public void verifyToken(LoginUser loginUser)  
    {  
        long expireTime = loginUser.getExpireTime();  
        long currentTime = System.currentTimeMillis();  
        if (expireTime - currentTime <= MILLIS_MINUTE_TEN)  
        {  
            refreshToken(loginUser);  
        }  
    }  
  
    /**  
     * 刷新令牌有效期  
     *   
* @param loginUser 登录信息  
     */  
    public void refreshToken(LoginUser loginUser)  
    {  
        loginUser.setLoginTime(System.currentTimeMillis());  
        loginUser.setExpireTime(loginUser.getLoginTime() + expireTime * MILLIS_MINUTE);  
        // 根据uuid将loginUser缓存  
        String userKey = getTokenKey(loginUser.getToken());  
        redisCache.setCacheObject(userKey, loginUser, expireTime, TimeUnit.MINUTES);  
    }  
      
    /**  
     * 设置用户代理信息  
     *   
* @param loginUser 登录信息  
     */  
    public void setUserAgent(LoginUser loginUser)  
    {  
        UserAgent userAgent = UserAgent.parseUserAgentString(ServletUtils.getRequest().getHeader("User-Agent"));  
        String ip = IpUtils.getIpAddr(ServletUtils.getRequest());  
        loginUser.setIpaddr(ip);  
        loginUser.setLoginLocation(AddressUtils.getRealAddressByIP(ip));  
        loginUser.setBrowser(userAgent.getBrowser().getName());  
        loginUser.setOs(userAgent.getOperatingSystem().getName());  
    }  
      
    /**  
     * 从数据声明生成令牌  
     *  
     * @param claims 数据声明  
     * @return 令牌  
     */  
    private String createToken(Map<String, Object> claims)  
    {  
        String token = Jwts.builder()  
                .setClaims(claims)  
                .signWith(SignatureAlgorithm.HS512, secret).compact();  
        return token;  
    }  
  
    /**  
     * 从令牌中获取数据声明  
     *  
     * @param token 令牌  
     * @return 数据声明  
     */  
    private Claims parseToken(String token)  
    {  
        return Jwts.parser()  
                .setSigningKey(secret)  
                .parseClaimsJws(token)  
                .getBody();  
    }  
  
    /**  
     * 从令牌中获取用户名  
     *  
     * @param token 令牌  
     * @return 用户名  
     */  
    public String getUsernameFromToken(String token)  
    {  
        Claims claims = parseToken(token);  
        return claims.getSubject();  
    }  
  
    /**  
     * 获取请求token  
     *     * @param request  
     * @return token  
     */    private String getToken(HttpServletRequest request)  
    {  
        String token = request.getHeader(header);  
        if (StringUtils.isNotEmpty(token) && token.startsWith(Constants.TOKEN_PREFIX))  
        {  
            token = token.replace(Constants.TOKEN_PREFIX, "");  
        }  
        return token;  
    }  
  
    private String getTokenKey(String uuid)  
    {  
        return Constants.LOGIN_TOKEN_KEY + uuid;  
    }  
}
```


```
// 令牌自定义标识  
@Value("${token.header}")  
private String header;
```
动态设置获取请求中的token的键值对的时候应该用哪个键
![](assets/Pasted%20image%2020250721113156.png)
用的authorization这个作为键

```
LoginUser loginUser = tokenService.getLoginUser(ServletUtils.getRequest());  
SysUser user = loginUser.getUser();
```
	Spring 框架在处理每个 HTTP 请求时，会将当前请求的 HttpServletRequest 和 HttpServletResponse 绑定到当前线程的 ThreadLocal 变量中。
	这里底层就是这样用的
请求头中根据动态设置的键获得token
然后进行解析token
根据键获得其中的uuid
根据uuid加前缀进行拼接得到新的键
在redis中根据这个键获得user返回
这个user中还有一个内嵌的一个user
外层User中包含各种浏览器类型等 内存user就是各种个人信息


```
DynamicDataSourceContextHolder.setDataSourceType("SLAVE");
```
切换数据源（底层就是threadlocal)


sql中返回了一堆，
但是
```
List<AbsenceVo> abesenceDetail(@Param("requestInfo") AbsenceRequestInfo requestI
```
这里有一个abxxVo
里面只有几个属性
所以sql查到的东西只用到了一点


```
PageHelper.startPage(requestInfo.getPageNum(), requestInfo.getPageSize());  
List<AbsenceVo> list = absencePeopleMapper.abesenceDetail(requestInfo, conditionSql, excludeIdList);  
return new PageInfo<>(list);
```
service层中
```
PageInfo<AbsenceVo> pageInfo = absencePeopleService.abesenceDetail(requestInfo, excludeIdList);  
return getDataTable(pageInfo.getList(), (int) pageInfo.getTotal());
```
controller
所以在s层中获取分页参数进行startpage然后进行sql查询
然后返回数据
c层再返回
getDataTable就是封装数据然后设置success之类的



```
String beginDate = requestInfo.getBeginDate();  
if(StringUtils.isNotEmpty(beginDate)){  
    LocalDate date = LocalDate.parse(beginDate, DateTimeFormatter.ofPattern("yyyy-MM-dd"));  
    LocalDate[] weekDates = WeekDateCalculator.getWeekStartAndEnd(date);  
    requestInfo.setBeginDate(weekDates[0].toString());  
    requestInfo.setEndDate(weekDates[1].toString());  
}
```
关于localdate的操作
时间



```
String sevenCondition = " (DS.C_CONTINUE_DAYS >= 7) ";  
List<ContinueWorkPeopleVo> list = attendanceOclassMapper.continueWork(requestInfo, conditionSql, sevenCondition);
```
这个地方直接进行手写sql插入了





# 常量

```
package com.o.common.constant;  
  
/**  
 * 返回状态码  
 *   
* @author HQ  
 */public class HttpStatus  
{  
    /**  
     * 操作成功  
     */  
    public static final int SUCCESS = 200;  
  
    /**  
     * 对象创建成功  
     */  
    public static final int CREATED = 201;  
  
    /**  
     * 请求已经被接受  
     */  
    public static final int ACCEPTED = 202;  
  
    /**  
     * 操作已经执行成功，但是没有返回数据  
     */  
    public static final int NO_CONTENT = 204;  
  
    /**  
     * 资源已被移除  
     */  
    public static final int MOVED_PERM = 301;  
  
    /**  
     * 重定向  
     */  
    public static final int SEE_OTHER = 303;  
  
    /**  
     * 资源没有被修改  
     */  
    public static final int NOT_MODIFIED = 304;  
  
    /**  
     * 参数列表错误（缺少，格式不匹配）  
     */  
    public static final int BAD_REQUEST = 400;  
  
    /**  
     * 未授权  
     */  
    public static final int UNAUTHORIZED = 401;  
  
    /**  
     * 访问受限，授权过期  
     */  
    public static final int FORBIDDEN = 403;  
  
    /**  
     * 资源，服务未找到  
     */  
    public static final int NOT_FOUND = 404;  
  
    /**  
     * 不允许的http方法  
     */  
    public static final int BAD_METHOD = 405;  
  
    /**  
     * 资源冲突，或者资源被锁  
     */  
    public static final int CONFLICT = 409;  
  
    /**  
     * 不支持的数据，媒体类型  
     */  
    public static final int UNSUPPORTED_TYPE = 415;  
  
    /**  
     * 系统内部错误  
     */  
    public static final int ERROR = 500;  
  
    /**  
     * 接口未实现  
     */  
    public static final int NOT_IMPLEMENTED = 501;  
}
```

## 枚举

```
public enum Status  
{  
    /**  
     * 正常  
     */  
    NORMAL("0"),  
    /**  
     * 暂停  
     */  
    PAUSE("1");  
  
    private String value;  
  
    private Status(String value)  
    {  
        this.value = value;  
    }  
  
    public String getValue()  
    {  
        return value;  
    }  
}
```


# begin1


# constant
通用常量
esb常量
代码生成常量
网络请求状态码常量
任务调度常量
用户常量


# core
uuid

字符集工具类
类型转换类
字符串格式化

# enums

银行信息枚举
基础信息枚举
个人户籍信息枚举
证件信息枚举
首次工作枚举

请求方式枚举
国际化枚举
国际化枚举  hcm数据库内和移动端对应
讲师等级枚举类
管理者自助角色枚举
菜单分类枚举
角色类型枚举（员工自助，管理员。管理员自助
成绩单适用人群枚举类型
用户和角色绑定 枚举
```java
ADMIN("00", "admin","系统管理员"),  
  
FEIO_ZHIZAO("4", "folzz","非o类制造（通用）"),  
FEIO_ZHIZAO_SXS("7", "folzz_sxs","非o类制造(实习生)"),//改用工方式获取是否是实习生
```
用户状态枚举
```java
OK("0", "正常"), DISABLE("1", "停用"), DELETED("2", "删除");
```
用户类型枚举（00系统用户） 员工类型 0-非o类非制造,3-非o类制造，4-o类非制造，5-o类制造


# exception

文件信息异常类
文件名称超长限制异常类
文件名大小限制异常类
文件上传 误异常类

计划策略异常

验证码错误异常类
验证码失效异常类
用户信息异常类 （继承基础异常
用户密码不正确或不符合规范异常类

基础异常
演示模式异常
工具类异常


# filter
Repeatable 过滤器
构建可重复读取inputStream的request
防止XSS攻击的过滤器
XSS过滤处理


# utils
bean
file上传，文件处理工具类、媒体类型工具类
加密相关的系统常数、加密解密的工具类、
转义和反转义工具类*、HTML过滤器，用于去除XSS漏洞隐患。
通用http工具封装、通用http发送方法
获取地址类、获取IP方法
### job
抽象quartz调用
cron表达式工具类
任务执行工具
* 定时任务处理（禁止并发执行）
* 定时任务处理（允许并发执行）
* 定时任务工具类
![](assets/Pasted%20image%2020250806105712.png)
两个 可不可以并发 继承了抽象任务 重写的方法使用了 jobinvoke util 里面的方法
然后在schedule里面进行判断来决定用哪个




Excel相关处理
* 反射工具类. 提供调用getter/setter方法, 访问私有变量, 调用私有方法, 获取泛型类型Class, 被AOP过的真实类等工具函数.
Md5加密方法
Base64工具类
* spring工具类 方便在非spring管理环境中获取bean
* * SQL中 LIKE 语句查询方式\<br>
sql操作工具类
解密类
精确的浮点数运算
BtoaEncodeUtils加解密工具类
超过1000处理
config配置常量
法大大平台-加密算法(3DESC)
时间工具类
字典工具类
EsbService工具类
错误信息处理类
电子签工具类
Http请求Service
ID生成器工具类
用户名密码加密工具类
处理并记录日志文件
获取i18n资源文件
安全服务工具类
客户端工具类
签名算法类型枚举
法大大-签名工具类
短信发送工具类
字符串工具类
线程相关工具类
验证码工具类
星期工具类
初始化国际化语言包 参数map
初始化国际化语言包 参数map


# framework

数据权限过滤注解
自定义多数据源切换注解
自定义导出Excel数据注解
Excel注解集
自定义操作日志记录注解

操作状态枚举
业务操作类型枚举数据源枚举
操作人类别枚举

数据过滤处理
多数据源处理
操作日志记录处理

druid 配置属性
程序注解配置
druid 配置多数据源
esb配置
Redis使用FastJson序列化
Filter配置
读取代码生成相关配置
读取项目相关配置
Mybatis支持匹配扫描包
redis配置
通用配置
RestTemplate无法自动装配，需要通过Configuration创建、同时使用连接池来提高服务请求速度
定时任务配置
spring security配置
国际化重写
服务相关配置
线程池配置

动态数据源
数据源切换处理

自定义注解防止表单重复提交
判断请求url和数据是否和上一次相同， 如果和上次相同，则是重复提交表单。 有效时间为10秒内。

防止重复提交拦截器

对接日志中台dto
日志监听事件
日志监听

异步工厂（产生任务用）
异步任务管理器
确保应用退出时能关闭后台线程
系统启动时加载SCM常数代码到redis
spring redis 工具类

token过滤器 验证token有效性
认证失败处理类 返回未授权
自定义退出处理类 返回成功

CustomLoginAuthenticationProvider自定义登录认证
HQ首创 自定义权限实现，ss取自SpringSecurity首字母
登录校验方法
用户权限处理
token验证处理
用户验证处理

获取路由子菜单
用户登录对象
登录用户身份权限


一堆task
一堆实体
全局异常
page相关实体














# 繁

定时任务，quartz用schdule 这jobdetail trigger来调用任务
jobdetail 组合 sysjob
sysjob里面有invoketarget这个是实际执行的任务内容

![](assets/Pasted%20image%2020250807120045.png)




# 多文件导出



左边是实现接口的关系，右边是 左边上面两个实现的时候用到了最右边那个通用的分发方法
![](assets/Pasted%20image%2020250930173151.png)
![](assets/Pasted%20image%2020250930173456.png)

最下面的文件还调用上面的俩

这个可以看调用树
![](assets/Pasted%20image%2020250930173207.png)





提交任务写法

```java
// src/main/java/com/jackasher/ageiport/controller/internal/InternalTaskController.java  
  
package com.jackasher.ageiport.listener;  
  
import java.io.Serializable;  
import java.util.concurrent.Executor;  
import java.util.concurrent.ExecutorService;  
  
import javax.annotation.Resource;  
  
import org.springframework.http.ResponseEntity;  
import org.springframework.web.bind.annotation.PostMapping;  
import org.springframework.web.bind.annotation.RequestBody;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
import com.jackasher.ageiport.dispatcher.GenericProcessingDispatcher;  
  
import lombok.Data;  
import lombok.extern.slf4j.Slf4j;  
  
/**  
 * 基于Http的事件监听,接收主节点的延迟任务触发通知  
 */  
@RestController  
@RequestMapping("/internal/api/task")  
@Slf4j  
public class InternalTaskController {  
  
    @Resource  
    private Executor serialAttachmentTaskExecutor;  
  
    @PostMapping("/trigger-deferred")  
    public ResponseEntity<String> triggerDeferredTask(@RequestBody TriggerPayload payload) {  
        log.info("收到Master节点HTTP指令，触发本节点对 mainTaskId: {} 的延迟任务检查", payload.getMainTaskId());  
            // 异步执行，立即返回，不阻塞Master节点的回调线程  
        /*意思是接受到通知需要延迟接收到的任务 传递进去 任务id 执行器       里面执行的就是 遍历任务依次触发(submit)*/  
            ((ExecutorService) serialAttachmentTaskExecutor).submit(() -> {  
                GenericProcessingDispatcher.triggerDeferredTasksSerially(payload.getMainTaskId(), (ExecutorService) serialAttachmentTaskExecutor);  
            });  
            return ResponseEntity.ok("指令已接收 for mainTaskId: " + payload.getMainTaskId());  
    }  
    @Data  
    public static class TriggerPayload implements Serializable {  
        private static final long serialVersionUID = 1L;  
        private String mainTaskId;  
    }  
}
```


![](assets/Pasted%20image%2020250930175911.png)
注意这个清除中断
可能有让别的线程检测到这个线程中断以及切实让这个线程中断的作用


